"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/outlayer";
exports.ids = ["vendor-chunks/outlayer"];
exports.modules = {

/***/ "(ssr)/./node_modules/outlayer/item.js":
/*!***************************************!*\
  !*** ./node_modules/outlayer/item.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Outlayer Item\n */ (function(window1, factory) {\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(EvEmitter, getSize) {\n    \"use strict\";\n    // ----- helpers ----- //\n    function isEmptyObj(obj) {\n        for(var prop in obj){\n            return false;\n        }\n        prop = null;\n        return true;\n    }\n    // -------------------------- CSS3 support -------------------------- //\n    var docElemStyle = document.documentElement.style;\n    var transitionProperty = typeof docElemStyle.transition == \"string\" ? \"transition\" : \"WebkitTransition\";\n    var transformProperty = typeof docElemStyle.transform == \"string\" ? \"transform\" : \"WebkitTransform\";\n    var transitionEndEvent = {\n        WebkitTransition: \"webkitTransitionEnd\",\n        transition: \"transitionend\"\n    }[transitionProperty];\n    // cache all vendor properties that could have vendor prefix\n    var vendorProperties = {\n        transform: transformProperty,\n        transition: transitionProperty,\n        transitionDuration: transitionProperty + \"Duration\",\n        transitionProperty: transitionProperty + \"Property\",\n        transitionDelay: transitionProperty + \"Delay\"\n    };\n    // -------------------------- Item -------------------------- //\n    function Item(element, layout) {\n        if (!element) {\n            return;\n        }\n        this.element = element;\n        // parent layout class, i.e. Masonry, Isotope, or Packery\n        this.layout = layout;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this._create();\n    }\n    // inherit EvEmitter\n    var proto = Item.prototype = Object.create(EvEmitter.prototype);\n    proto.constructor = Item;\n    proto._create = function() {\n        // transition objects\n        this._transn = {\n            ingProperties: {},\n            clean: {},\n            onEnd: {}\n        };\n        this.css({\n            position: \"absolute\"\n        });\n    };\n    // trigger specified handler for event type\n    proto.handleEvent = function(event) {\n        var method = \"on\" + event.type;\n        if (this[method]) {\n            this[method](event);\n        }\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * apply CSS styles to element\n * @param {Object} style\n */ proto.css = function(style) {\n        var elemStyle = this.element.style;\n        for(var prop in style){\n            // use vendor property if available\n            var supportedProp = vendorProperties[prop] || prop;\n            elemStyle[supportedProp] = style[prop];\n        }\n    };\n    // measure position, and sets it\n    proto.getPosition = function() {\n        var style = getComputedStyle(this.element);\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        var xValue = style[isOriginLeft ? \"left\" : \"right\"];\n        var yValue = style[isOriginTop ? \"top\" : \"bottom\"];\n        var x = parseFloat(xValue);\n        var y = parseFloat(yValue);\n        // convert percent to pixels\n        var layoutSize = this.layout.size;\n        if (xValue.indexOf(\"%\") != -1) {\n            x = x / 100 * layoutSize.width;\n        }\n        if (yValue.indexOf(\"%\") != -1) {\n            y = y / 100 * layoutSize.height;\n        }\n        // clean up 'auto' or other non-integer values\n        x = isNaN(x) ? 0 : x;\n        y = isNaN(y) ? 0 : y;\n        // remove padding from measurement\n        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n        this.position.x = x;\n        this.position.y = y;\n    };\n    // set settled position, apply padding\n    proto.layoutPosition = function() {\n        var layoutSize = this.layout.size;\n        var style = {};\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        // x\n        var xPadding = isOriginLeft ? \"paddingLeft\" : \"paddingRight\";\n        var xProperty = isOriginLeft ? \"left\" : \"right\";\n        var xResetProperty = isOriginLeft ? \"right\" : \"left\";\n        var x = this.position.x + layoutSize[xPadding];\n        // set in percentage or pixels\n        style[xProperty] = this.getXValue(x);\n        // reset other property\n        style[xResetProperty] = \"\";\n        // y\n        var yPadding = isOriginTop ? \"paddingTop\" : \"paddingBottom\";\n        var yProperty = isOriginTop ? \"top\" : \"bottom\";\n        var yResetProperty = isOriginTop ? \"bottom\" : \"top\";\n        var y = this.position.y + layoutSize[yPadding];\n        // set in percentage or pixels\n        style[yProperty] = this.getYValue(y);\n        // reset other property\n        style[yResetProperty] = \"\";\n        this.css(style);\n        this.emitEvent(\"layout\", [\n            this\n        ]);\n    };\n    proto.getXValue = function(x) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + \"%\" : x + \"px\";\n    };\n    proto.getYValue = function(y) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + \"%\" : y + \"px\";\n    };\n    proto._transitionTo = function(x, y) {\n        this.getPosition();\n        // get current x & y from top/left\n        var curX = this.position.x;\n        var curY = this.position.y;\n        var didNotMove = x == this.position.x && y == this.position.y;\n        // save end position\n        this.setPosition(x, y);\n        // if did not move and not transitioning, just go to layout\n        if (didNotMove && !this.isTransitioning) {\n            this.layoutPosition();\n            return;\n        }\n        var transX = x - curX;\n        var transY = y - curY;\n        var transitionStyle = {};\n        transitionStyle.transform = this.getTranslate(transX, transY);\n        this.transition({\n            to: transitionStyle,\n            onTransitionEnd: {\n                transform: this.layoutPosition\n            },\n            isCleaning: true\n        });\n    };\n    proto.getTranslate = function(x, y) {\n        // flip cooridinates if origin on right or bottom\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        x = isOriginLeft ? x : -x;\n        y = isOriginTop ? y : -y;\n        return \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n    };\n    // non transition + transform support\n    proto.goTo = function(x, y) {\n        this.setPosition(x, y);\n        this.layoutPosition();\n    };\n    proto.moveTo = proto._transitionTo;\n    proto.setPosition = function(x, y) {\n        this.position.x = parseFloat(x);\n        this.position.y = parseFloat(y);\n    };\n    // ----- transition ----- //\n    /**\n * @param {Object} style - CSS\n * @param {Function} onTransitionEnd\n */ // non transition, just trigger callback\n    proto._nonTransition = function(args) {\n        this.css(args.to);\n        if (args.isCleaning) {\n            this._removeStyles(args.to);\n        }\n        for(var prop in args.onTransitionEnd){\n            args.onTransitionEnd[prop].call(this);\n        }\n    };\n    /**\n * proper transition\n * @param {Object} args - arguments\n *   @param {Object} to - style to transition to\n *   @param {Object} from - style to start transition from\n *   @param {Boolean} isCleaning - removes transition styles after transition\n *   @param {Function} onTransitionEnd - callback\n */ proto.transition = function(args) {\n        // redirect to nonTransition if no transition duration\n        if (!parseFloat(this.layout.options.transitionDuration)) {\n            this._nonTransition(args);\n            return;\n        }\n        var _transition = this._transn;\n        // keep track of onTransitionEnd callback by css property\n        for(var prop in args.onTransitionEnd){\n            _transition.onEnd[prop] = args.onTransitionEnd[prop];\n        }\n        // keep track of properties that are transitioning\n        for(prop in args.to){\n            _transition.ingProperties[prop] = true;\n            // keep track of properties to clean up when transition is done\n            if (args.isCleaning) {\n                _transition.clean[prop] = true;\n            }\n        }\n        // set from styles\n        if (args.from) {\n            this.css(args.from);\n            // force redraw. http://blog.alexmaccaw.com/css-transitions\n            var h = this.element.offsetHeight;\n            // hack for JSHint to hush about unused var\n            h = null;\n        }\n        // enable transition\n        this.enableTransition(args.to);\n        // set styles that are transitioning\n        this.css(args.to);\n        this.isTransitioning = true;\n    };\n    // dash before all cap letters, including first for\n    // WebkitTransform => -webkit-transform\n    function toDashedAll(str) {\n        return str.replace(/([A-Z])/g, function($1) {\n            return \"-\" + $1.toLowerCase();\n        });\n    }\n    var transitionProps = \"opacity,\" + toDashedAll(transformProperty);\n    proto.enableTransition = function() {\n        // HACK changing transitionProperty during a transition\n        // will cause transition to jump\n        if (this.isTransitioning) {\n            return;\n        }\n        // make `transition: foo, bar, baz` from style object\n        // HACK un-comment this when enableTransition can work\n        // while a transition is happening\n        // var transitionValues = [];\n        // for ( var prop in style ) {\n        //   // dash-ify camelCased properties like WebkitTransition\n        //   prop = vendorProperties[ prop ] || prop;\n        //   transitionValues.push( toDashedAll( prop ) );\n        // }\n        // munge number to millisecond, to match stagger\n        var duration = this.layout.options.transitionDuration;\n        duration = typeof duration == \"number\" ? duration + \"ms\" : duration;\n        // enable transition styles\n        this.css({\n            transitionProperty: transitionProps,\n            transitionDuration: duration,\n            transitionDelay: this.staggerDelay || 0\n        });\n        // listen for transition end event\n        this.element.addEventListener(transitionEndEvent, this, false);\n    };\n    // ----- events ----- //\n    proto.onwebkitTransitionEnd = function(event) {\n        this.ontransitionend(event);\n    };\n    proto.onotransitionend = function(event) {\n        this.ontransitionend(event);\n    };\n    // properties that I munge to make my life easier\n    var dashedVendorProperties = {\n        \"-webkit-transform\": \"transform\"\n    };\n    proto.ontransitionend = function(event) {\n        // disregard bubbled events from children\n        if (event.target !== this.element) {\n            return;\n        }\n        var _transition = this._transn;\n        // get property name of transitioned property, convert to prefix-free\n        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;\n        // remove property that has completed transitioning\n        delete _transition.ingProperties[propertyName];\n        // check if any properties are still transitioning\n        if (isEmptyObj(_transition.ingProperties)) {\n            // all properties have completed transitioning\n            this.disableTransition();\n        }\n        // clean style\n        if (propertyName in _transition.clean) {\n            // clean up style\n            this.element.style[event.propertyName] = \"\";\n            delete _transition.clean[propertyName];\n        }\n        // trigger onTransitionEnd callback\n        if (propertyName in _transition.onEnd) {\n            var onTransitionEnd = _transition.onEnd[propertyName];\n            onTransitionEnd.call(this);\n            delete _transition.onEnd[propertyName];\n        }\n        this.emitEvent(\"transitionEnd\", [\n            this\n        ]);\n    };\n    proto.disableTransition = function() {\n        this.removeTransitionStyles();\n        this.element.removeEventListener(transitionEndEvent, this, false);\n        this.isTransitioning = false;\n    };\n    /**\n * removes style property from element\n * @param {Object} style\n**/ proto._removeStyles = function(style) {\n        // clean up transition styles\n        var cleanStyle = {};\n        for(var prop in style){\n            cleanStyle[prop] = \"\";\n        }\n        this.css(cleanStyle);\n    };\n    var cleanTransitionStyle = {\n        transitionProperty: \"\",\n        transitionDuration: \"\",\n        transitionDelay: \"\"\n    };\n    proto.removeTransitionStyles = function() {\n        // remove transition\n        this.css(cleanTransitionStyle);\n    };\n    // ----- stagger ----- //\n    proto.stagger = function(delay) {\n        delay = isNaN(delay) ? 0 : delay;\n        this.staggerDelay = delay + \"ms\";\n    };\n    // ----- show/hide/remove ----- //\n    // remove element from DOM\n    proto.removeElem = function() {\n        this.element.parentNode.removeChild(this.element);\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        this.emitEvent(\"remove\", [\n            this\n        ]);\n    };\n    proto.remove = function() {\n        // just remove element if no transition support or no transition\n        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n            this.removeElem();\n            return;\n        }\n        // start transition\n        this.once(\"transitionEnd\", function() {\n            this.removeElem();\n        });\n        this.hide();\n    };\n    proto.reveal = function() {\n        delete this.isHidden;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"visibleStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n        this.transition({\n            from: options.hiddenStyle,\n            to: options.visibleStyle,\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onRevealTransitionEnd = function() {\n        // check if still visible\n        // during transition, item may have been hidden\n        if (!this.isHidden) {\n            this.emitEvent(\"reveal\");\n        }\n    };\n    /**\n * get style property use for hide/reveal transition end\n * @param {String} styleProperty - hiddenStyle/visibleStyle\n * @returns {String}\n */ proto.getHideRevealTransitionEndProperty = function(styleProperty) {\n        var optionStyle = this.layout.options[styleProperty];\n        // use opacity\n        if (optionStyle.opacity) {\n            return \"opacity\";\n        }\n        // get first property\n        for(var prop in optionStyle){\n            return prop;\n        }\n    };\n    proto.hide = function() {\n        // set flag\n        this.isHidden = true;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"hiddenStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n        this.transition({\n            from: options.visibleStyle,\n            to: options.hiddenStyle,\n            // keep hidden stuff hidden\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onHideTransitionEnd = function() {\n        // check if still hidden\n        // during transition, item may have been un-hidden\n        if (this.isHidden) {\n            this.css({\n                display: \"none\"\n            });\n            this.emitEvent(\"hide\");\n        }\n    };\n    proto.destroy = function() {\n        this.css({\n            position: \"\",\n            left: \"\",\n            right: \"\",\n            top: \"\",\n            bottom: \"\",\n            transition: \"\",\n            transform: \"\"\n        });\n    };\n    return Item;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTRDLHNCQUF1QixHQUFHLElBQUksQ0FBQ1EsbUJBQW1CO1FBRW5FLElBQUksQ0FBQzVILFVBQVUsQ0FBQztZQUNkaUYsTUFBTXRCLFFBQVE2RCxZQUFZO1lBQzFCakQsSUFBSVosUUFBUTRELFdBQVc7WUFDdkIsMkJBQTJCO1lBQzNCOUMsWUFBWTtZQUNaRCxpQkFBaUJBO1FBQ25CO0lBQ0Y7SUFFQTFELE1BQU04RyxtQkFBbUIsR0FBRztRQUMxQix3QkFBd0I7UUFDeEIsa0RBQWtEO1FBQ2xELElBQUssSUFBSSxDQUFDVCxRQUFRLEVBQUc7WUFDbkIsSUFBSSxDQUFDNUYsR0FBRyxDQUFDO2dCQUFFdUYsU0FBUztZQUFPO1lBQzNCLElBQUksQ0FBQ3JELFNBQVMsQ0FBQztRQUNqQjtJQUNGO0lBRUEzQyxNQUFNK0csT0FBTyxHQUFHO1FBQ2QsSUFBSSxDQUFDdEcsR0FBRyxDQUFDO1lBQ1BiLFVBQVU7WUFDVm9ILE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1lBQ0xDLFFBQVE7WUFDUmpJLFlBQVk7WUFDWkUsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPYjtBQUVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlhamVzLy4vbm9kZV9tb2R1bGVzL291dGxheWVyL2l0ZW0uanM/OWE1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE91dGxheWVyIEl0ZW1cbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBbXG4gICAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnXG4gICAgICBdLFxuICAgICAgZmFjdG9yeVxuICAgICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuT3V0bGF5ZXIgPSB7fTtcbiAgICB3aW5kb3cuT3V0bGF5ZXIuSXRlbSA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgd2luZG93LmdldFNpemVcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggRXZFbWl0dGVyLCBnZXRTaXplICkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLSBoZWxwZXJzIC0tLS0tIC8vXG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmooIG9iaiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gb2JqICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9wID0gbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENTUzMgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cbnZhciBkb2NFbGVtU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cbnZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSB0eXBlb2YgZG9jRWxlbVN0eWxlLnRyYW5zaXRpb24gPT0gJ3N0cmluZycgP1xuICAndHJhbnNpdGlvbicgOiAnV2Via2l0VHJhbnNpdGlvbic7XG52YXIgdHJhbnNmb3JtUHJvcGVydHkgPSB0eXBlb2YgZG9jRWxlbVN0eWxlLnRyYW5zZm9ybSA9PSAnc3RyaW5nJyA/XG4gICd0cmFuc2Zvcm0nIDogJ1dlYmtpdFRyYW5zZm9ybSc7XG5cbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSB7XG4gIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG59WyB0cmFuc2l0aW9uUHJvcGVydHkgXTtcblxuLy8gY2FjaGUgYWxsIHZlbmRvciBwcm9wZXJ0aWVzIHRoYXQgY291bGQgaGF2ZSB2ZW5kb3IgcHJlZml4XG52YXIgdmVuZG9yUHJvcGVydGllcyA9IHtcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1Qcm9wZXJ0eSxcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvblByb3BlcnR5LFxuICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdEdXJhdGlvbicsXG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogdHJhbnNpdGlvblByb3BlcnR5ICsgJ1Byb3BlcnR5JyxcbiAgdHJhbnNpdGlvbkRlbGF5OiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnRGVsYXknXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJdGVtIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIEl0ZW0oIGVsZW1lbnQsIGxheW91dCApIHtcbiAgaWYgKCAhZWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAvLyBwYXJlbnQgbGF5b3V0IGNsYXNzLCBpLmUuIE1hc29ucnksIElzb3RvcGUsIG9yIFBhY2tlcnlcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMucG9zaXRpb24gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cbi8vIGluaGVyaXQgRXZFbWl0dGVyXG52YXIgcHJvdG8gPSBJdGVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcbnByb3RvLmNvbnN0cnVjdG9yID0gSXRlbTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB0cmFuc2l0aW9uIG9iamVjdHNcbiAgdGhpcy5fdHJhbnNuID0ge1xuICAgIGluZ1Byb3BlcnRpZXM6IHt9LFxuICAgIGNsZWFuOiB7fSxcbiAgICBvbkVuZDoge31cbiAgfTtcblxuICB0aGlzLmNzcyh7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG59O1xuXG4vLyB0cmlnZ2VyIHNwZWNpZmllZCBoYW5kbGVyIGZvciBldmVudCB0eXBlXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxuLyoqXG4gKiBhcHBseSBDU1Mgc3R5bGVzIHRvIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICovXG5wcm90by5jc3MgPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIHZhciBlbGVtU3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG5cbiAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgLy8gdXNlIHZlbmRvciBwcm9wZXJ0eSBpZiBhdmFpbGFibGVcbiAgICB2YXIgc3VwcG9ydGVkUHJvcCA9IHZlbmRvclByb3BlcnRpZXNbIHByb3AgXSB8fCBwcm9wO1xuICAgIGVsZW1TdHlsZVsgc3VwcG9ydGVkUHJvcCBdID0gc3R5bGVbIHByb3AgXTtcbiAgfVxufTtcblxuIC8vIG1lYXN1cmUgcG9zaXRpb24sIGFuZCBzZXRzIGl0XG5wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIHZhciB4VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JyBdO1xuICB2YXIgeVZhbHVlID0gc3R5bGVbIGlzT3JpZ2luVG9wID8gJ3RvcCcgOiAnYm90dG9tJyBdO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoIHhWYWx1ZSApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoIHlWYWx1ZSApO1xuICAvLyBjb252ZXJ0IHBlcmNlbnQgdG8gcGl4ZWxzXG4gIHZhciBsYXlvdXRTaXplID0gdGhpcy5sYXlvdXQuc2l6ZTtcbiAgaWYgKCB4VmFsdWUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgIHggPSAoIHggLyAxMDAgKSAqIGxheW91dFNpemUud2lkdGg7XG4gIH1cbiAgaWYgKCB5VmFsdWUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgIHkgPSAoIHkgLyAxMDAgKSAqIGxheW91dFNpemUuaGVpZ2h0O1xuICB9XG4gIC8vIGNsZWFuIHVwICdhdXRvJyBvciBvdGhlciBub24taW50ZWdlciB2YWx1ZXNcbiAgeCA9IGlzTmFOKCB4ICkgPyAwIDogeDtcbiAgeSA9IGlzTmFOKCB5ICkgPyAwIDogeTtcbiAgLy8gcmVtb3ZlIHBhZGRpbmcgZnJvbSBtZWFzdXJlbWVudFxuICB4IC09IGlzT3JpZ2luTGVmdCA/IGxheW91dFNpemUucGFkZGluZ0xlZnQgOiBsYXlvdXRTaXplLnBhZGRpbmdSaWdodDtcbiAgeSAtPSBpc09yaWdpblRvcCA/IGxheW91dFNpemUucGFkZGluZ1RvcCA6IGxheW91dFNpemUucGFkZGluZ0JvdHRvbTtcblxuICB0aGlzLnBvc2l0aW9uLnggPSB4O1xuICB0aGlzLnBvc2l0aW9uLnkgPSB5O1xufTtcblxuLy8gc2V0IHNldHRsZWQgcG9zaXRpb24sIGFwcGx5IHBhZGRpbmdcbnByb3RvLmxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYXlvdXRTaXplID0gdGhpcy5sYXlvdXQuc2l6ZTtcbiAgdmFyIHN0eWxlID0ge307XG4gIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuXG4gIC8vIHhcbiAgdmFyIHhQYWRkaW5nID0gaXNPcmlnaW5MZWZ0ID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICB2YXIgeFByb3BlcnR5ID0gaXNPcmlnaW5MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgdmFyIHhSZXNldFByb3BlcnR5ID0gaXNPcmlnaW5MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcblxuICB2YXIgeCA9IHRoaXMucG9zaXRpb24ueCArIGxheW91dFNpemVbIHhQYWRkaW5nIF07XG4gIC8vIHNldCBpbiBwZXJjZW50YWdlIG9yIHBpeGVsc1xuICBzdHlsZVsgeFByb3BlcnR5IF0gPSB0aGlzLmdldFhWYWx1ZSggeCApO1xuICAvLyByZXNldCBvdGhlciBwcm9wZXJ0eVxuICBzdHlsZVsgeFJlc2V0UHJvcGVydHkgXSA9ICcnO1xuXG4gIC8vIHlcbiAgdmFyIHlQYWRkaW5nID0gaXNPcmlnaW5Ub3AgPyAncGFkZGluZ1RvcCcgOiAncGFkZGluZ0JvdHRvbSc7XG4gIHZhciB5UHJvcGVydHkgPSBpc09yaWdpblRvcCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciB5UmVzZXRQcm9wZXJ0eSA9IGlzT3JpZ2luVG9wID8gJ2JvdHRvbScgOiAndG9wJztcblxuICB2YXIgeSA9IHRoaXMucG9zaXRpb24ueSArIGxheW91dFNpemVbIHlQYWRkaW5nIF07XG4gIC8vIHNldCBpbiBwZXJjZW50YWdlIG9yIHBpeGVsc1xuICBzdHlsZVsgeVByb3BlcnR5IF0gPSB0aGlzLmdldFlWYWx1ZSggeSApO1xuICAvLyByZXNldCBvdGhlciBwcm9wZXJ0eVxuICBzdHlsZVsgeVJlc2V0UHJvcGVydHkgXSA9ICcnO1xuXG4gIHRoaXMuY3NzKCBzdHlsZSApO1xuICB0aGlzLmVtaXRFdmVudCggJ2xheW91dCcsIFsgdGhpcyBdICk7XG59O1xuXG5wcm90by5nZXRYVmFsdWUgPSBmdW5jdGlvbiggeCApIHtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ2hvcml6b250YWwnKTtcbiAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGVyY2VudFBvc2l0aW9uICYmICFpc0hvcml6b250YWwgP1xuICAgICggKCB4IC8gdGhpcy5sYXlvdXQuc2l6ZS53aWR0aCApICogMTAwICkgKyAnJScgOiB4ICsgJ3B4Jztcbn07XG5cbnByb3RvLmdldFlWYWx1ZSA9IGZ1bmN0aW9uKCB5ICkge1xuICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignaG9yaXpvbnRhbCcpO1xuICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5wZXJjZW50UG9zaXRpb24gJiYgaXNIb3Jpem9udGFsID9cbiAgICAoICggeSAvIHRoaXMubGF5b3V0LnNpemUuaGVpZ2h0ICkgKiAxMDAgKSArICclJyA6IHkgKyAncHgnO1xufTtcblxucHJvdG8uX3RyYW5zaXRpb25UbyA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLmdldFBvc2l0aW9uKCk7XG4gIC8vIGdldCBjdXJyZW50IHggJiB5IGZyb20gdG9wL2xlZnRcbiAgdmFyIGN1clggPSB0aGlzLnBvc2l0aW9uLng7XG4gIHZhciBjdXJZID0gdGhpcy5wb3NpdGlvbi55O1xuXG4gIHZhciBkaWROb3RNb3ZlID0geCA9PSB0aGlzLnBvc2l0aW9uLnggJiYgeSA9PSB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgLy8gc2F2ZSBlbmQgcG9zaXRpb25cbiAgdGhpcy5zZXRQb3NpdGlvbiggeCwgeSApO1xuXG4gIC8vIGlmIGRpZCBub3QgbW92ZSBhbmQgbm90IHRyYW5zaXRpb25pbmcsIGp1c3QgZ28gdG8gbGF5b3V0XG4gIGlmICggZGlkTm90TW92ZSAmJiAhdGhpcy5pc1RyYW5zaXRpb25pbmcgKSB7XG4gICAgdGhpcy5sYXlvdXRQb3NpdGlvbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0cmFuc1ggPSB4IC0gY3VyWDtcbiAgdmFyIHRyYW5zWSA9IHkgLSBjdXJZO1xuICB2YXIgdHJhbnNpdGlvblN0eWxlID0ge307XG4gIHRyYW5zaXRpb25TdHlsZS50cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zbGF0ZSggdHJhbnNYLCB0cmFuc1kgKTtcblxuICB0aGlzLnRyYW5zaXRpb24oe1xuICAgIHRvOiB0cmFuc2l0aW9uU3R5bGUsXG4gICAgb25UcmFuc2l0aW9uRW5kOiB7XG4gICAgICB0cmFuc2Zvcm06IHRoaXMubGF5b3V0UG9zaXRpb25cbiAgICB9LFxuICAgIGlzQ2xlYW5pbmc6IHRydWVcbiAgfSk7XG59O1xuXG5wcm90by5nZXRUcmFuc2xhdGUgPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgLy8gZmxpcCBjb29yaWRpbmF0ZXMgaWYgb3JpZ2luIG9uIHJpZ2h0IG9yIGJvdHRvbVxuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcbiAgeCA9IGlzT3JpZ2luTGVmdCA/IHggOiAteDtcbiAgeSA9IGlzT3JpZ2luVG9wID8geSA6IC15O1xuICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMCknO1xufTtcblxuLy8gbm9uIHRyYW5zaXRpb24gKyB0cmFuc2Zvcm0gc3VwcG9ydFxucHJvdG8uZ29UbyA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLnNldFBvc2l0aW9uKCB4LCB5ICk7XG4gIHRoaXMubGF5b3V0UG9zaXRpb24oKTtcbn07XG5cbnByb3RvLm1vdmVUbyA9IHByb3RvLl90cmFuc2l0aW9uVG87XG5cbnByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMucG9zaXRpb24ueCA9IHBhcnNlRmxvYXQoIHggKTtcbiAgdGhpcy5wb3NpdGlvbi55ID0gcGFyc2VGbG9hdCggeSApO1xufTtcblxuLy8gLS0tLS0gdHJhbnNpdGlvbiAtLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAtIENTU1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcmFuc2l0aW9uRW5kXG4gKi9cblxuLy8gbm9uIHRyYW5zaXRpb24sIGp1c3QgdHJpZ2dlciBjYWxsYmFja1xucHJvdG8uX25vblRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgdGhpcy5jc3MoIGFyZ3MudG8gKTtcbiAgaWYgKCBhcmdzLmlzQ2xlYW5pbmcgKSB7XG4gICAgdGhpcy5fcmVtb3ZlU3R5bGVzKCBhcmdzLnRvICk7XG4gIH1cbiAgZm9yICggdmFyIHByb3AgaW4gYXJncy5vblRyYW5zaXRpb25FbmQgKSB7XG4gICAgYXJncy5vblRyYW5zaXRpb25FbmRbIHByb3AgXS5jYWxsKCB0aGlzICk7XG4gIH1cbn07XG5cbi8qKlxuICogcHJvcGVyIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gYXJndW1lbnRzXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSB0byAtIHN0eWxlIHRvIHRyYW5zaXRpb24gdG9cbiAqICAgQHBhcmFtIHtPYmplY3R9IGZyb20gLSBzdHlsZSB0byBzdGFydCB0cmFuc2l0aW9uIGZyb21cbiAqICAgQHBhcmFtIHtCb29sZWFufSBpc0NsZWFuaW5nIC0gcmVtb3ZlcyB0cmFuc2l0aW9uIHN0eWxlcyBhZnRlciB0cmFuc2l0aW9uXG4gKiAgIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJhbnNpdGlvbkVuZCAtIGNhbGxiYWNrXG4gKi9cbnByb3RvLnRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgLy8gcmVkaXJlY3QgdG8gbm9uVHJhbnNpdGlvbiBpZiBubyB0cmFuc2l0aW9uIGR1cmF0aW9uXG4gIGlmICggIXBhcnNlRmxvYXQoIHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uICkgKSB7XG4gICAgdGhpcy5fbm9uVHJhbnNpdGlvbiggYXJncyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zbjtcbiAgLy8ga2VlcCB0cmFjayBvZiBvblRyYW5zaXRpb25FbmQgY2FsbGJhY2sgYnkgY3NzIHByb3BlcnR5XG4gIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgIF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wIF0gPSBhcmdzLm9uVHJhbnNpdGlvbkVuZFsgcHJvcCBdO1xuICB9XG4gIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gIGZvciAoIHByb3AgaW4gYXJncy50byApIHtcbiAgICBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzWyBwcm9wIF0gPSB0cnVlO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0byBjbGVhbiB1cCB3aGVuIHRyYW5zaXRpb24gaXMgZG9uZVxuICAgIGlmICggYXJncy5pc0NsZWFuaW5nICkge1xuICAgICAgX3RyYW5zaXRpb24uY2xlYW5bIHByb3AgXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGZyb20gc3R5bGVzXG4gIGlmICggYXJncy5mcm9tICkge1xuICAgIHRoaXMuY3NzKCBhcmdzLmZyb20gKTtcbiAgICAvLyBmb3JjZSByZWRyYXcuIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAgIHZhciBoID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAvLyBoYWNrIGZvciBKU0hpbnQgdG8gaHVzaCBhYm91dCB1bnVzZWQgdmFyXG4gICAgaCA9IG51bGw7XG4gIH1cbiAgLy8gZW5hYmxlIHRyYW5zaXRpb25cbiAgdGhpcy5lbmFibGVUcmFuc2l0aW9uKCBhcmdzLnRvICk7XG4gIC8vIHNldCBzdHlsZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZ1xuICB0aGlzLmNzcyggYXJncy50byApO1xuXG4gIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxufTtcblxuLy8gZGFzaCBiZWZvcmUgYWxsIGNhcCBsZXR0ZXJzLCBpbmNsdWRpbmcgZmlyc3QgZm9yXG4vLyBXZWJraXRUcmFuc2Zvcm0gPT4gLXdlYmtpdC10cmFuc2Zvcm1cbmZ1bmN0aW9uIHRvRGFzaGVkQWxsKCBzdHIgKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSggLyhbQS1aXSkvZywgZnVuY3Rpb24oICQxICkge1xuICAgIHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9ICdvcGFjaXR5LCcgKyB0b0Rhc2hlZEFsbCggdHJhbnNmb3JtUHJvcGVydHkgKTtcblxucHJvdG8uZW5hYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKC8qIHN0eWxlICovKSB7XG4gIC8vIEhBQ0sgY2hhbmdpbmcgdHJhbnNpdGlvblByb3BlcnR5IGR1cmluZyBhIHRyYW5zaXRpb25cbiAgLy8gd2lsbCBjYXVzZSB0cmFuc2l0aW9uIHRvIGp1bXBcbiAgaWYgKCB0aGlzLmlzVHJhbnNpdGlvbmluZyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIGB0cmFuc2l0aW9uOiBmb28sIGJhciwgYmF6YCBmcm9tIHN0eWxlIG9iamVjdFxuICAvLyBIQUNLIHVuLWNvbW1lbnQgdGhpcyB3aGVuIGVuYWJsZVRyYW5zaXRpb24gY2FuIHdvcmtcbiAgLy8gd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGhhcHBlbmluZ1xuICAvLyB2YXIgdHJhbnNpdGlvblZhbHVlcyA9IFtdO1xuICAvLyBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgLy8gICAvLyBkYXNoLWlmeSBjYW1lbENhc2VkIHByb3BlcnRpZXMgbGlrZSBXZWJraXRUcmFuc2l0aW9uXG4gIC8vICAgcHJvcCA9IHZlbmRvclByb3BlcnRpZXNbIHByb3AgXSB8fCBwcm9wO1xuICAvLyAgIHRyYW5zaXRpb25WYWx1ZXMucHVzaCggdG9EYXNoZWRBbGwoIHByb3AgKSApO1xuICAvLyB9XG4gIC8vIG11bmdlIG51bWJlciB0byBtaWxsaXNlY29uZCwgdG8gbWF0Y2ggc3RhZ2dlclxuICB2YXIgZHVyYXRpb24gPSB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgZHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT0gJ251bWJlcicgPyBkdXJhdGlvbiArICdtcycgOiBkdXJhdGlvbjtcbiAgLy8gZW5hYmxlIHRyYW5zaXRpb24gc3R5bGVzXG4gIHRoaXMuY3NzKHtcbiAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wcyxcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IGR1cmF0aW9uLFxuICAgIHRyYW5zaXRpb25EZWxheTogdGhpcy5zdGFnZ2VyRGVsYXkgfHwgMFxuICB9KTtcbiAgLy8gbGlzdGVuIGZvciB0cmFuc2l0aW9uIGVuZCBldmVudFxuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCB0aGlzLCBmYWxzZSApO1xufTtcblxuLy8gLS0tLS0gZXZlbnRzIC0tLS0tIC8vXG5cbnByb3RvLm9ud2Via2l0VHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5vbnRyYW5zaXRpb25lbmQoIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbm90cmFuc2l0aW9uZW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLm9udHJhbnNpdGlvbmVuZCggZXZlbnQgKTtcbn07XG5cbi8vIHByb3BlcnRpZXMgdGhhdCBJIG11bmdlIHRvIG1ha2UgbXkgbGlmZSBlYXNpZXJcbnZhciBkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzID0ge1xuICAnLXdlYmtpdC10cmFuc2Zvcm0nOiAndHJhbnNmb3JtJ1xufTtcblxucHJvdG8ub250cmFuc2l0aW9uZW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAvLyBkaXNyZWdhcmQgYnViYmxlZCBldmVudHMgZnJvbSBjaGlsZHJlblxuICBpZiAoIGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3RyYW5zaXRpb24gPSB0aGlzLl90cmFuc247XG4gIC8vIGdldCBwcm9wZXJ0eSBuYW1lIG9mIHRyYW5zaXRpb25lZCBwcm9wZXJ0eSwgY29udmVydCB0byBwcmVmaXgtZnJlZVxuICB2YXIgcHJvcGVydHlOYW1lID0gZGFzaGVkVmVuZG9yUHJvcGVydGllc1sgZXZlbnQucHJvcGVydHlOYW1lIF0gfHwgZXZlbnQucHJvcGVydHlOYW1lO1xuXG4gIC8vIHJlbW92ZSBwcm9wZXJ0eSB0aGF0IGhhcyBjb21wbGV0ZWQgdHJhbnNpdGlvbmluZ1xuICBkZWxldGUgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcGVydHlOYW1lIF07XG4gIC8vIGNoZWNrIGlmIGFueSBwcm9wZXJ0aWVzIGFyZSBzdGlsbCB0cmFuc2l0aW9uaW5nXG4gIGlmICggaXNFbXB0eU9iaiggX3RyYW5zaXRpb24uaW5nUHJvcGVydGllcyApICkge1xuICAgIC8vIGFsbCBwcm9wZXJ0aWVzIGhhdmUgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgICB0aGlzLmRpc2FibGVUcmFuc2l0aW9uKCk7XG4gIH1cbiAgLy8gY2xlYW4gc3R5bGVcbiAgaWYgKCBwcm9wZXJ0eU5hbWUgaW4gX3RyYW5zaXRpb24uY2xlYW4gKSB7XG4gICAgLy8gY2xlYW4gdXAgc3R5bGVcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIGV2ZW50LnByb3BlcnR5TmFtZSBdID0gJyc7XG4gICAgZGVsZXRlIF90cmFuc2l0aW9uLmNsZWFuWyBwcm9wZXJ0eU5hbWUgXTtcbiAgfVxuICAvLyB0cmlnZ2VyIG9uVHJhbnNpdGlvbkVuZCBjYWxsYmFja1xuICBpZiAoIHByb3BlcnR5TmFtZSBpbiBfdHJhbnNpdGlvbi5vbkVuZCApIHtcbiAgICB2YXIgb25UcmFuc2l0aW9uRW5kID0gX3RyYW5zaXRpb24ub25FbmRbIHByb3BlcnR5TmFtZSBdO1xuICAgIG9uVHJhbnNpdGlvbkVuZC5jYWxsKCB0aGlzICk7XG4gICAgZGVsZXRlIF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wZXJ0eU5hbWUgXTtcbiAgfVxuXG4gIHRoaXMuZW1pdEV2ZW50KCAndHJhbnNpdGlvbkVuZCcsIFsgdGhpcyBdICk7XG59O1xuXG5wcm90by5kaXNhYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZVRyYW5zaXRpb25TdHlsZXMoKTtcbiAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbiAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogcmVtb3ZlcyBzdHlsZSBwcm9wZXJ0eSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuKiovXG5wcm90by5fcmVtb3ZlU3R5bGVzID0gZnVuY3Rpb24oIHN0eWxlICkge1xuICAvLyBjbGVhbiB1cCB0cmFuc2l0aW9uIHN0eWxlc1xuICB2YXIgY2xlYW5TdHlsZSA9IHt9O1xuICBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgICBjbGVhblN0eWxlWyBwcm9wIF0gPSAnJztcbiAgfVxuICB0aGlzLmNzcyggY2xlYW5TdHlsZSApO1xufTtcblxudmFyIGNsZWFuVHJhbnNpdGlvblN0eWxlID0ge1xuICB0cmFuc2l0aW9uUHJvcGVydHk6ICcnLFxuICB0cmFuc2l0aW9uRHVyYXRpb246ICcnLFxuICB0cmFuc2l0aW9uRGVsYXk6ICcnXG59O1xuXG5wcm90by5yZW1vdmVUcmFuc2l0aW9uU3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlbW92ZSB0cmFuc2l0aW9uXG4gIHRoaXMuY3NzKCBjbGVhblRyYW5zaXRpb25TdHlsZSApO1xufTtcblxuLy8gLS0tLS0gc3RhZ2dlciAtLS0tLSAvL1xuXG5wcm90by5zdGFnZ2VyID0gZnVuY3Rpb24oIGRlbGF5ICkge1xuICBkZWxheSA9IGlzTmFOKCBkZWxheSApID8gMCA6IGRlbGF5O1xuICB0aGlzLnN0YWdnZXJEZWxheSA9IGRlbGF5ICsgJ21zJztcbn07XG5cbi8vIC0tLS0tIHNob3cvaGlkZS9yZW1vdmUgLS0tLS0gLy9cblxuLy8gcmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbnByb3RvLnJlbW92ZUVsZW0gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICB0aGlzLmVtaXRFdmVudCggJ3JlbW92ZScsIFsgdGhpcyBdICk7XG59O1xuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgLy8ganVzdCByZW1vdmUgZWxlbWVudCBpZiBubyB0cmFuc2l0aW9uIHN1cHBvcnQgb3Igbm8gdHJhbnNpdGlvblxuICBpZiAoICF0cmFuc2l0aW9uUHJvcGVydHkgfHwgIXBhcnNlRmxvYXQoIHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uICkgKSB7XG4gICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RhcnQgdHJhbnNpdGlvblxuICB0aGlzLm9uY2UoICd0cmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gIH0pO1xuICB0aGlzLmhpZGUoKTtcbn07XG5cbnByb3RvLnJldmVhbCA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5pc0hpZGRlbjtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMubGF5b3V0Lm9wdGlvbnM7XG5cbiAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICB2YXIgdHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gdGhpcy5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5KCd2aXNpYmxlU3R5bGUnKTtcbiAgb25UcmFuc2l0aW9uRW5kWyB0cmFuc2l0aW9uRW5kUHJvcGVydHkgXSA9IHRoaXMub25SZXZlYWxUcmFuc2l0aW9uRW5kO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgZnJvbTogb3B0aW9ucy5oaWRkZW5TdHlsZSxcbiAgICB0bzogb3B0aW9ucy52aXNpYmxlU3R5bGUsXG4gICAgaXNDbGVhbmluZzogdHJ1ZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICB9KTtcbn07XG5cbnByb3RvLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBjaGVjayBpZiBzdGlsbCB2aXNpYmxlXG4gIC8vIGR1cmluZyB0cmFuc2l0aW9uLCBpdGVtIG1heSBoYXZlIGJlZW4gaGlkZGVuXG4gIGlmICggIXRoaXMuaXNIaWRkZW4gKSB7XG4gICAgdGhpcy5lbWl0RXZlbnQoJ3JldmVhbCcpO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCBzdHlsZSBwcm9wZXJ0eSB1c2UgZm9yIGhpZGUvcmV2ZWFsIHRyYW5zaXRpb24gZW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGVQcm9wZXJ0eSAtIGhpZGRlblN0eWxlL3Zpc2libGVTdHlsZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xucHJvdG8uZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBzdHlsZVByb3BlcnR5ICkge1xuICB2YXIgb3B0aW9uU3R5bGUgPSB0aGlzLmxheW91dC5vcHRpb25zWyBzdHlsZVByb3BlcnR5IF07XG4gIC8vIHVzZSBvcGFjaXR5XG4gIGlmICggb3B0aW9uU3R5bGUub3BhY2l0eSApIHtcbiAgICByZXR1cm4gJ29wYWNpdHknO1xuICB9XG4gIC8vIGdldCBmaXJzdCBwcm9wZXJ0eVxuICBmb3IgKCB2YXIgcHJvcCBpbiBvcHRpb25TdHlsZSApIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxucHJvdG8uaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBzZXQgZmxhZ1xuICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMubGF5b3V0Lm9wdGlvbnM7XG5cbiAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICB2YXIgdHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gdGhpcy5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5KCdoaWRkZW5TdHlsZScpO1xuICBvblRyYW5zaXRpb25FbmRbIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSBdID0gdGhpcy5vbkhpZGVUcmFuc2l0aW9uRW5kO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgZnJvbTogb3B0aW9ucy52aXNpYmxlU3R5bGUsXG4gICAgdG86IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgLy8ga2VlcCBoaWRkZW4gc3R1ZmYgaGlkZGVuXG4gICAgaXNDbGVhbmluZzogdHJ1ZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICB9KTtcbn07XG5cbnByb3RvLm9uSGlkZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgaWYgc3RpbGwgaGlkZGVuXG4gIC8vIGR1cmluZyB0cmFuc2l0aW9uLCBpdGVtIG1heSBoYXZlIGJlZW4gdW4taGlkZGVuXG4gIGlmICggdGhpcy5pc0hpZGRlbiApIHtcbiAgICB0aGlzLmNzcyh7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICB0aGlzLmVtaXRFdmVudCgnaGlkZScpO1xuICB9XG59O1xuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3NzKHtcbiAgICBwb3NpdGlvbjogJycsXG4gICAgbGVmdDogJycsXG4gICAgcmlnaHQ6ICcnLFxuICAgIHRvcDogJycsXG4gICAgYm90dG9tOiAnJyxcbiAgICB0cmFuc2l0aW9uOiAnJyxcbiAgICB0cmFuc2Zvcm06ICcnXG4gIH0pO1xufTtcblxucmV0dXJuIEl0ZW07XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJPdXRsYXllciIsIkl0ZW0iLCJFdkVtaXR0ZXIiLCJnZXRTaXplIiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJkb2NFbGVtU3R5bGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNpdGlvbiIsInRyYW5zZm9ybVByb3BlcnR5IiwidHJhbnNmb3JtIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiV2Via2l0VHJhbnNpdGlvbiIsInZlbmRvclByb3BlcnRpZXMiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uRGVsYXkiLCJlbGVtZW50IiwibGF5b3V0IiwicG9zaXRpb24iLCJ4IiwieSIsIl9jcmVhdGUiLCJwcm90byIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX3RyYW5zbiIsImluZ1Byb3BlcnRpZXMiLCJjbGVhbiIsIm9uRW5kIiwiY3NzIiwiaGFuZGxlRXZlbnQiLCJldmVudCIsIm1ldGhvZCIsInR5cGUiLCJzaXplIiwiZWxlbVN0eWxlIiwic3VwcG9ydGVkUHJvcCIsImdldFBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzT3JpZ2luTGVmdCIsIl9nZXRPcHRpb24iLCJpc09yaWdpblRvcCIsInhWYWx1ZSIsInlWYWx1ZSIsInBhcnNlRmxvYXQiLCJsYXlvdXRTaXplIiwiaW5kZXhPZiIsIndpZHRoIiwiaGVpZ2h0IiwiaXNOYU4iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwibGF5b3V0UG9zaXRpb24iLCJ4UGFkZGluZyIsInhQcm9wZXJ0eSIsInhSZXNldFByb3BlcnR5IiwiZ2V0WFZhbHVlIiwieVBhZGRpbmciLCJ5UHJvcGVydHkiLCJ5UmVzZXRQcm9wZXJ0eSIsImdldFlWYWx1ZSIsImVtaXRFdmVudCIsImlzSG9yaXpvbnRhbCIsIm9wdGlvbnMiLCJwZXJjZW50UG9zaXRpb24iLCJfdHJhbnNpdGlvblRvIiwiY3VyWCIsImN1clkiLCJkaWROb3RNb3ZlIiwic2V0UG9zaXRpb24iLCJpc1RyYW5zaXRpb25pbmciLCJ0cmFuc1giLCJ0cmFuc1kiLCJ0cmFuc2l0aW9uU3R5bGUiLCJnZXRUcmFuc2xhdGUiLCJ0byIsIm9uVHJhbnNpdGlvbkVuZCIsImlzQ2xlYW5pbmciLCJnb1RvIiwibW92ZVRvIiwiX25vblRyYW5zaXRpb24iLCJhcmdzIiwiX3JlbW92ZVN0eWxlcyIsImNhbGwiLCJfdHJhbnNpdGlvbiIsImZyb20iLCJoIiwib2Zmc2V0SGVpZ2h0IiwiZW5hYmxlVHJhbnNpdGlvbiIsInRvRGFzaGVkQWxsIiwic3RyIiwicmVwbGFjZSIsIiQxIiwidG9Mb3dlckNhc2UiLCJ0cmFuc2l0aW9uUHJvcHMiLCJkdXJhdGlvbiIsInN0YWdnZXJEZWxheSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbndlYmtpdFRyYW5zaXRpb25FbmQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbm90cmFuc2l0aW9uZW5kIiwiZGFzaGVkVmVuZG9yUHJvcGVydGllcyIsInRhcmdldCIsInByb3BlcnR5TmFtZSIsImRpc2FibGVUcmFuc2l0aW9uIiwicmVtb3ZlVHJhbnNpdGlvblN0eWxlcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhblN0eWxlIiwiY2xlYW5UcmFuc2l0aW9uU3R5bGUiLCJzdGFnZ2VyIiwiZGVsYXkiLCJyZW1vdmVFbGVtIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZGlzcGxheSIsInJlbW92ZSIsIm9uY2UiLCJoaWRlIiwicmV2ZWFsIiwiaXNIaWRkZW4iLCJ0cmFuc2l0aW9uRW5kUHJvcGVydHkiLCJnZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5Iiwib25SZXZlYWxUcmFuc2l0aW9uRW5kIiwiaGlkZGVuU3R5bGUiLCJ2aXNpYmxlU3R5bGUiLCJzdHlsZVByb3BlcnR5Iiwib3B0aW9uU3R5bGUiLCJvcGFjaXR5Iiwib25IaWRlVHJhbnNpdGlvbkVuZCIsImRlc3Ryb3kiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/outlayer/outlayer.js":
/*!*******************************************!*\
  !*** ./node_modules/outlayer/outlayer.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */ (function(window1, factory) {\n    \"use strict\";\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\"),\n            __webpack_require__(/*! fizzy-ui-utils/utils */ \"(ssr)/./node_modules/fizzy-ui-utils/utils.js\"),\n            __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/outlayer/item.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(EvEmitter, getSize, utils, Item) {\n            return factory(window1, EvEmitter, getSize, utils, Item);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(window1, EvEmitter, getSize, utils, Item) {\n    \"use strict\";\n    // ----- vars ----- //\n    var console = window1.console;\n    var jQuery = window1.jQuery;\n    var noop = function() {};\n    // -------------------------- Outlayer -------------------------- //\n    // globally unique identifiers\n    var GUID = 0;\n    // internal store of all Outlayer intances\n    var instances = {};\n    /**\n * @param {Element, String} element\n * @param {Object} options\n * @constructor\n */ function Outlayer(element, options) {\n        var queryElement = utils.getQueryElement(element);\n        if (!queryElement) {\n            if (console) {\n                console.error(\"Bad element for \" + this.constructor.namespace + \": \" + (queryElement || element));\n            }\n            return;\n        }\n        this.element = queryElement;\n        // add jQuery\n        if (jQuery) {\n            this.$element = jQuery(this.element);\n        }\n        // options\n        this.options = utils.extend({}, this.constructor.defaults);\n        this.option(options);\n        // add id for Outlayer.getFromElement\n        var id = ++GUID;\n        this.element.outlayerGUID = id; // expando\n        instances[id] = this; // associate via id\n        // kick it off\n        this._create();\n        var isInitLayout = this._getOption(\"initLayout\");\n        if (isInitLayout) {\n            this.layout();\n        }\n    }\n    // settings are for internal use only\n    Outlayer.namespace = \"outlayer\";\n    Outlayer.Item = Item;\n    // default options\n    Outlayer.defaults = {\n        containerStyle: {\n            position: \"relative\"\n        },\n        initLayout: true,\n        originLeft: true,\n        originTop: true,\n        resize: true,\n        resizeContainer: true,\n        // item options\n        transitionDuration: \"0.4s\",\n        hiddenStyle: {\n            opacity: 0,\n            transform: \"scale(0.001)\"\n        },\n        visibleStyle: {\n            opacity: 1,\n            transform: \"scale(1)\"\n        }\n    };\n    var proto = Outlayer.prototype;\n    // inherit EvEmitter\n    utils.extend(proto, EvEmitter.prototype);\n    /**\n * set options\n * @param {Object} opts\n */ proto.option = function(opts) {\n        utils.extend(this.options, opts);\n    };\n    /**\n * get backwards compatible option value, check old name\n */ proto._getOption = function(option) {\n        var oldOption = this.constructor.compatOptions[option];\n        return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];\n    };\n    Outlayer.compatOptions = {\n        // currentName: oldName\n        initLayout: \"isInitLayout\",\n        horizontal: \"isHorizontal\",\n        layoutInstant: \"isLayoutInstant\",\n        originLeft: \"isOriginLeft\",\n        originTop: \"isOriginTop\",\n        resize: \"isResizeBound\",\n        resizeContainer: \"isResizingContainer\"\n    };\n    proto._create = function() {\n        // get items from children\n        this.reloadItems();\n        // elements that affect layout, but are not laid out\n        this.stamps = [];\n        this.stamp(this.options.stamp);\n        // set container style\n        utils.extend(this.element.style, this.options.containerStyle);\n        // bind resize method\n        var canBindResize = this._getOption(\"resize\");\n        if (canBindResize) {\n            this.bindResize();\n        }\n    };\n    // goes through all children again and gets bricks in proper order\n    proto.reloadItems = function() {\n        // collection of item elements\n        this.items = this._itemize(this.element.children);\n    };\n    /**\n * turn elements into Outlayer.Items to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Outlayer Items\n */ proto._itemize = function(elems) {\n        var itemElems = this._filterFindItemElements(elems);\n        var Item = this.constructor.Item;\n        // create new Outlayer Items for collection\n        var items = [];\n        for(var i = 0; i < itemElems.length; i++){\n            var elem = itemElems[i];\n            var item = new Item(elem, this);\n            items.push(item);\n        }\n        return items;\n    };\n    /**\n * get item elements to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - item elements\n */ proto._filterFindItemElements = function(elems) {\n        return utils.filterFindElements(elems, this.options.itemSelector);\n    };\n    /**\n * getter method for getting item elements\n * @returns {Array} elems - collection of item elements\n */ proto.getItemElements = function() {\n        return this.items.map(function(item) {\n            return item.element;\n        });\n    };\n    // ----- init & layout ----- //\n    /**\n * lays out all items\n */ proto.layout = function() {\n        this._resetLayout();\n        this._manageStamps();\n        // don't animate first layout\n        var layoutInstant = this._getOption(\"layoutInstant\");\n        var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;\n        this.layoutItems(this.items, isInstant);\n        // flag for initalized\n        this._isLayoutInited = true;\n    };\n    // _init is alias for layout\n    proto._init = proto.layout;\n    /**\n * logic before any new layout\n */ proto._resetLayout = function() {\n        this.getSize();\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * get measurement from option, for columnWidth, rowHeight, gutter\n * if option is String -> get element from selector string, & get size of element\n * if option is Element -> get size of element\n * else use option as a number\n *\n * @param {String} measurement\n * @param {String} size - width or height\n * @private\n */ proto._getMeasurement = function(measurement, size) {\n        var option = this.options[measurement];\n        var elem;\n        if (!option) {\n            // default to 0\n            this[measurement] = 0;\n        } else {\n            // use option as an element\n            if (typeof option == \"string\") {\n                elem = this.element.querySelector(option);\n            } else if (option instanceof HTMLElement) {\n                elem = option;\n            }\n            // use size of element, if element\n            this[measurement] = elem ? getSize(elem)[size] : option;\n        }\n    };\n    /**\n * layout a collection of item elements\n * @api public\n */ proto.layoutItems = function(items, isInstant) {\n        items = this._getItemsForLayout(items);\n        this._layoutItems(items, isInstant);\n        this._postLayout();\n    };\n    /**\n * get the items to be laid out\n * you may want to skip over some items\n * @param {Array} items\n * @returns {Array} items\n */ proto._getItemsForLayout = function(items) {\n        return items.filter(function(item) {\n            return !item.isIgnored;\n        });\n    };\n    /**\n * layout items\n * @param {Array} items\n * @param {Boolean} isInstant\n */ proto._layoutItems = function(items, isInstant) {\n        this._emitCompleteOnItems(\"layout\", items);\n        if (!items || !items.length) {\n            // no items, emit event with empty array\n            return;\n        }\n        var queue = [];\n        items.forEach(function(item) {\n            // get x/y object from method\n            var position = this._getItemLayoutPosition(item);\n            // enqueue\n            position.item = item;\n            position.isInstant = isInstant || item.isLayoutInstant;\n            queue.push(position);\n        }, this);\n        this._processLayoutQueue(queue);\n    };\n    /**\n * get item layout position\n * @param {Outlayer.Item} item\n * @returns {Object} x and y position\n */ proto._getItemLayoutPosition = function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    };\n    /**\n * iterate over array and position each item\n * Reason being - separating this logic prevents 'layout invalidation'\n * thx @paul_irish\n * @param {Array} queue\n */ proto._processLayoutQueue = function(queue) {\n        this.updateStagger();\n        queue.forEach(function(obj, i) {\n            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n        }, this);\n    };\n    // set stagger from option in milliseconds number\n    proto.updateStagger = function() {\n        var stagger = this.options.stagger;\n        if (stagger === null || stagger === undefined) {\n            this.stagger = 0;\n            return;\n        }\n        this.stagger = getMilliseconds(stagger);\n        return this.stagger;\n    };\n    /**\n * Sets position of item in DOM\n * @param {Outlayer.Item} item\n * @param {Number} x - horizontal position\n * @param {Number} y - vertical position\n * @param {Boolean} isInstant - disables transitions\n */ proto._positionItem = function(item, x, y, isInstant, i) {\n        if (isInstant) {\n            // if not transition, just set CSS\n            item.goTo(x, y);\n        } else {\n            item.stagger(i * this.stagger);\n            item.moveTo(x, y);\n        }\n    };\n    /**\n * Any logic you want to do after each layout,\n * i.e. size the container\n */ proto._postLayout = function() {\n        this.resizeContainer();\n    };\n    proto.resizeContainer = function() {\n        var isResizingContainer = this._getOption(\"resizeContainer\");\n        if (!isResizingContainer) {\n            return;\n        }\n        var size = this._getContainerSize();\n        if (size) {\n            this._setContainerMeasure(size.width, true);\n            this._setContainerMeasure(size.height, false);\n        }\n    };\n    /**\n * Sets width or height of container if returned\n * @returns {Object} size\n *   @param {Number} width\n *   @param {Number} height\n */ proto._getContainerSize = noop;\n    /**\n * @param {Number} measure - size of width or height\n * @param {Boolean} isWidth\n */ proto._setContainerMeasure = function(measure, isWidth) {\n        if (measure === undefined) {\n            return;\n        }\n        var elemSize = this.size;\n        // add padding and border width if border box\n        if (elemSize.isBorderBox) {\n            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n        }\n        measure = Math.max(measure, 0);\n        this.element.style[isWidth ? \"width\" : \"height\"] = measure + \"px\";\n    };\n    /**\n * emit eventComplete on a collection of items events\n * @param {String} eventName\n * @param {Array} items - Outlayer.Items\n */ proto._emitCompleteOnItems = function(eventName, items) {\n        var _this = this;\n        function onComplete() {\n            _this.dispatchEvent(eventName + \"Complete\", null, [\n                items\n            ]);\n        }\n        var count = items.length;\n        if (!items || !count) {\n            onComplete();\n            return;\n        }\n        var doneCount = 0;\n        function tick() {\n            doneCount++;\n            if (doneCount == count) {\n                onComplete();\n            }\n        }\n        // bind callback\n        items.forEach(function(item) {\n            item.once(eventName, tick);\n        });\n    };\n    /**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */ proto.dispatchEvent = function(type, event, args) {\n        // add original event to arguments\n        var emitArgs = event ? [\n            event\n        ].concat(args) : args;\n        this.emitEvent(type, emitArgs);\n        if (jQuery) {\n            // set this.$element\n            this.$element = this.$element || jQuery(this.element);\n            if (event) {\n                // create jQuery event\n                var $event = jQuery.Event(event);\n                $event.type = type;\n                this.$element.trigger($event, args);\n            } else {\n                // just trigger with type if no event available\n                this.$element.trigger(type, args);\n            }\n        }\n    };\n    // -------------------------- ignore & stamps -------------------------- //\n    /**\n * keep item in collection, but do not lay it out\n * ignored items do not get skipped in layout\n * @param {Element} elem\n */ proto.ignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            item.isIgnored = true;\n        }\n    };\n    /**\n * return item to layout collection\n * @param {Element} elem\n */ proto.unignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            delete item.isIgnored;\n        }\n    };\n    /**\n * adds elements to stamps\n * @param {NodeList, Array, Element, or String} elems\n */ proto.stamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        this.stamps = this.stamps.concat(elems);\n        // ignore\n        elems.forEach(this.ignore, this);\n    };\n    /**\n * removes elements to stamps\n * @param {NodeList, Array, or Element} elems\n */ proto.unstamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        elems.forEach(function(elem) {\n            // filter out removed stamp elements\n            utils.removeFrom(this.stamps, elem);\n            this.unignore(elem);\n        }, this);\n    };\n    /**\n * finds child elements\n * @param {NodeList, Array, Element, or String} elems\n * @returns {Array} elems\n */ proto._find = function(elems) {\n        if (!elems) {\n            return;\n        }\n        // if string, use argument as selector string\n        if (typeof elems == \"string\") {\n            elems = this.element.querySelectorAll(elems);\n        }\n        elems = utils.makeArray(elems);\n        return elems;\n    };\n    proto._manageStamps = function() {\n        if (!this.stamps || !this.stamps.length) {\n            return;\n        }\n        this._getBoundingRect();\n        this.stamps.forEach(this._manageStamp, this);\n    };\n    // update boundingLeft / Top\n    proto._getBoundingRect = function() {\n        // get bounding rect for container element\n        var boundingRect = this.element.getBoundingClientRect();\n        var size = this.size;\n        this._boundingRect = {\n            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n            top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n        };\n    };\n    /**\n * @param {Element} stamp\n**/ proto._manageStamp = noop;\n    /**\n * get x/y position of element relative to container element\n * @param {Element} elem\n * @returns {Object} offset - has left, top, right, bottom\n */ proto._getElementOffset = function(elem) {\n        var boundingRect = elem.getBoundingClientRect();\n        var thisRect = this._boundingRect;\n        var size = getSize(elem);\n        var offset = {\n            left: boundingRect.left - thisRect.left - size.marginLeft,\n            top: boundingRect.top - thisRect.top - size.marginTop,\n            right: thisRect.right - boundingRect.right - size.marginRight,\n            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n        };\n        return offset;\n    };\n    // -------------------------- resize -------------------------- //\n    // enable event handlers for listeners\n    // i.e. resize -> onresize\n    proto.handleEvent = utils.handleEvent;\n    /**\n * Bind layout to window resizing\n */ proto.bindResize = function() {\n        window1.addEventListener(\"resize\", this);\n        this.isResizeBound = true;\n    };\n    /**\n * Unbind layout to window resizing\n */ proto.unbindResize = function() {\n        window1.removeEventListener(\"resize\", this);\n        this.isResizeBound = false;\n    };\n    proto.onresize = function() {\n        this.resize();\n    };\n    utils.debounceMethod(Outlayer, \"onresize\", 100);\n    proto.resize = function() {\n        // don't trigger if size did not change\n        // or if resize was unbound. See #9\n        if (!this.isResizeBound || !this.needsResizeLayout()) {\n            return;\n        }\n        this.layout();\n    };\n    /**\n * check if layout is needed post layout\n * @returns Boolean\n */ proto.needsResizeLayout = function() {\n        var size = getSize(this.element);\n        // check that this.size and size are there\n        // IE8 triggers resize on body size change, so they might not be\n        var hasSizes = this.size && size;\n        return hasSizes && size.innerWidth !== this.size.innerWidth;\n    };\n    // -------------------------- methods -------------------------- //\n    /**\n * add items to Outlayer instance\n * @param {Array or NodeList or Element} elems\n * @returns {Array} items - Outlayer.Items\n**/ proto.addItems = function(elems) {\n        var items = this._itemize(elems);\n        // add items to collection\n        if (items.length) {\n            this.items = this.items.concat(items);\n        }\n        return items;\n    };\n    /**\n * Layout newly-appended item elements\n * @param {Array or NodeList or Element} elems\n */ proto.appended = function(elems) {\n        var items = this.addItems(elems);\n        if (!items.length) {\n            return;\n        }\n        // layout and reveal just the new items\n        this.layoutItems(items, true);\n        this.reveal(items);\n    };\n    /**\n * Layout prepended elements\n * @param {Array or NodeList or Element} elems\n */ proto.prepended = function(elems) {\n        var items = this._itemize(elems);\n        if (!items.length) {\n            return;\n        }\n        // add items to beginning of collection\n        var previousItems = this.items.slice(0);\n        this.items = items.concat(previousItems);\n        // start new layout\n        this._resetLayout();\n        this._manageStamps();\n        // layout new stuff without transition\n        this.layoutItems(items, true);\n        this.reveal(items);\n        // layout previous items\n        this.layoutItems(previousItems);\n    };\n    /**\n * reveal a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.reveal = function(items) {\n        this._emitCompleteOnItems(\"reveal\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.reveal();\n        });\n    };\n    /**\n * hide a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.hide = function(items) {\n        this._emitCompleteOnItems(\"hide\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.hide();\n        });\n    };\n    /**\n * reveal item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.revealItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.reveal(items);\n    };\n    /**\n * hide item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.hideItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.hide(items);\n    };\n    /**\n * get Outlayer.Item, given an Element\n * @param {Element} elem\n * @param {Function} callback\n * @returns {Outlayer.Item} item\n */ proto.getItem = function(elem) {\n        // loop through items to get the one that matches\n        for(var i = 0; i < this.items.length; i++){\n            var item = this.items[i];\n            if (item.element == elem) {\n                // return item\n                return item;\n            }\n        }\n    };\n    /**\n * get collection of Outlayer.Items, given Elements\n * @param {Array} elems\n * @returns {Array} items - Outlayer.Items\n */ proto.getItems = function(elems) {\n        elems = utils.makeArray(elems);\n        var items = [];\n        elems.forEach(function(elem) {\n            var item = this.getItem(elem);\n            if (item) {\n                items.push(item);\n            }\n        }, this);\n        return items;\n    };\n    /**\n * remove element(s) from instance and DOM\n * @param {Array or NodeList or Element} elems\n */ proto.remove = function(elems) {\n        var removeItems = this.getItems(elems);\n        this._emitCompleteOnItems(\"remove\", removeItems);\n        // bail if no items to remove\n        if (!removeItems || !removeItems.length) {\n            return;\n        }\n        removeItems.forEach(function(item) {\n            item.remove();\n            // remove item from collection\n            utils.removeFrom(this.items, item);\n        }, this);\n    };\n    // ----- destroy ----- //\n    // remove and disable Outlayer instance\n    proto.destroy = function() {\n        // clean up dynamic styles\n        var style = this.element.style;\n        style.height = \"\";\n        style.position = \"\";\n        style.width = \"\";\n        // destroy items\n        this.items.forEach(function(item) {\n            item.destroy();\n        });\n        this.unbindResize();\n        var id = this.element.outlayerGUID;\n        delete instances[id]; // remove reference to instance by id\n        delete this.element.outlayerGUID;\n        // remove data for jQuery\n        if (jQuery) {\n            jQuery.removeData(this.element, this.constructor.namespace);\n        }\n    };\n    // -------------------------- data -------------------------- //\n    /**\n * get Outlayer instance from element\n * @param {Element} elem\n * @returns {Outlayer}\n */ Outlayer.data = function(elem) {\n        elem = utils.getQueryElement(elem);\n        var id = elem && elem.outlayerGUID;\n        return id && instances[id];\n    };\n    // -------------------------- create Outlayer class -------------------------- //\n    /**\n * create a layout class\n * @param {String} namespace\n */ Outlayer.create = function(namespace, options) {\n        // sub-class Outlayer\n        var Layout = subclass(Outlayer);\n        // apply new options and compatOptions\n        Layout.defaults = utils.extend({}, Outlayer.defaults);\n        utils.extend(Layout.defaults, options);\n        Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n        Layout.namespace = namespace;\n        Layout.data = Outlayer.data;\n        // sub-class Item\n        Layout.Item = subclass(Item);\n        // -------------------------- declarative -------------------------- //\n        utils.htmlInit(Layout, namespace);\n        // -------------------------- jQuery bridge -------------------------- //\n        // make into jQuery plugin\n        if (jQuery && jQuery.bridget) {\n            jQuery.bridget(namespace, Layout);\n        }\n        return Layout;\n    };\n    function subclass(Parent) {\n        function SubClass() {\n            Parent.apply(this, arguments);\n        }\n        SubClass.prototype = Object.create(Parent.prototype);\n        SubClass.prototype.constructor = SubClass;\n        return SubClass;\n    }\n    // ----- helpers ----- //\n    // how many milliseconds are in each unit\n    var msUnits = {\n        ms: 1,\n        s: 1000\n    };\n    // munge time-like parameter into millisecond number\n    // '0.4s' -> 40\n    function getMilliseconds(time) {\n        if (typeof time == \"number\") {\n            return time;\n        }\n        var matches = time.match(/(^\\d*\\.?\\d*)(\\w*)/);\n        var num = matches && matches[1];\n        var unit = matches && matches[2];\n        if (!num.length) {\n            return 0;\n        }\n        num = parseFloat(num);\n        var mult = msUnits[unit] || 1;\n        return num * mult;\n    }\n    // ----- fin ----- //\n    // back in global\n    Outlayer.Item = Item;\n    return Outlayer;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvb3V0bGF5ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0NBSUMsR0FFQyxVQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDekI7SUFDQSw4QkFBOEI7SUFDOUIsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQzlELElBQUssSUFBeUMsRUFBRztRQUMvQyxrQkFBa0I7UUFDbEJDLGlDQUFRO1lBQ0o7WUFDQTtZQUNBO1lBQ0E7U0FDRCxtQ0FDRCxTQUFVRSxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxJQUFJO1lBQ3ZDLE9BQU9OLFFBQVNELFNBQVFJLFdBQVdDLFNBQVNDLE9BQU9DO1FBQ3JELENBQUM7QUFBQTtJQUVMLE9BQU8sRUFrQk47QUFFSCxHQUFHUCxRQUFRLFNBQVNDLFFBQVNELE9BQU0sRUFBRUksU0FBUyxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUNwRTtJQUVBLHNCQUFzQjtJQUV0QixJQUFJTSxVQUFVYixRQUFPYSxPQUFPO0lBQzVCLElBQUlDLFNBQVNkLFFBQU9jLE1BQU07SUFDMUIsSUFBSUMsT0FBTyxZQUFZO0lBRXZCLG9FQUFvRTtJQUVwRSw4QkFBOEI7SUFDOUIsSUFBSUMsT0FBTztJQUNYLDBDQUEwQztJQUMxQyxJQUFJQyxZQUFZLENBQUM7SUFHakI7Ozs7Q0FJQyxHQUNELFNBQVNOLFNBQVVPLE9BQU8sRUFBRUMsT0FBTztRQUNqQyxJQUFJQyxlQUFlZCxNQUFNZSxlQUFlLENBQUVIO1FBQzFDLElBQUssQ0FBQ0UsY0FBZTtZQUNuQixJQUFLUCxTQUFVO2dCQUNiQSxRQUFRUyxLQUFLLENBQUUscUJBQXFCLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxTQUFTLEdBQzVELE9BQVNKLENBQUFBLGdCQUFnQkYsT0FBTTtZQUNuQztZQUNBO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLE9BQU8sR0FBR0U7UUFDZixhQUFhO1FBQ2IsSUFBS04sUUFBUztZQUNaLElBQUksQ0FB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T0EsUUFBUSxVQUFXO1lBQzdCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJQyxVQUFVRCxLQUFLRSxLQUFLLENBQUU7UUFDMUIsSUFBSUMsTUFBTUYsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDL0IsSUFBSUcsT0FBT0gsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDaEMsSUFBSyxDQUFDRSxJQUFJNUksTUFBTSxFQUFHO1lBQ2pCLE9BQU87UUFDVDtRQUNBNEksTUFBTUUsV0FBWUY7UUFDbEIsSUFBSUcsT0FBT1QsT0FBTyxDQUFFTyxLQUFNLElBQUk7UUFDOUIsT0FBT0QsTUFBTUc7SUFDZjtJQUVBLHFCQUFxQjtJQUVyQixpQkFBaUI7SUFDakJ4TSxTQUFTSixJQUFJLEdBQUdBO0lBRWhCLE9BQU9JO0FBRVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWFqZXMvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvb3V0bGF5ZXIuanM/MzIwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE91dGxheWVyIHYyLjEuMVxuICogdGhlIGJyYWlucyBhbmQgZ3V0cyBvZiBhIGxheW91dCBsaWJyYXJ5XG4gKiBNSVQgbGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggW1xuICAgICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcbiAgICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJyxcbiAgICAgICAgJy4vaXRlbSdcbiAgICAgIF0sXG4gICAgICBmdW5jdGlvbiggRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJyksXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKSxcbiAgICAgIHJlcXVpcmUoJy4vaXRlbScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5PdXRsYXllciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgd2luZG93LmdldFNpemUsXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzLFxuICAgICAgd2luZG93Lk91dGxheWVyLkl0ZW1cbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtICkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLSB2YXJzIC0tLS0tIC8vXG5cbnZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG52YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gT3V0bGF5ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXJzXG52YXIgR1VJRCA9IDA7XG4vLyBpbnRlcm5hbCBzdG9yZSBvZiBhbGwgT3V0bGF5ZXIgaW50YW5jZXNcbnZhciBpbnN0YW5jZXMgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCwgU3RyaW5nfSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE91dGxheWVyKCBlbGVtZW50LCBvcHRpb25zICkge1xuICB2YXIgcXVlcnlFbGVtZW50ID0gdXRpbHMuZ2V0UXVlcnlFbGVtZW50KCBlbGVtZW50ICk7XG4gIGlmICggIXF1ZXJ5RWxlbWVudCApIHtcbiAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAnQmFkIGVsZW1lbnQgZm9yICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWVzcGFjZSArXG4gICAgICAgICc6ICcgKyAoIHF1ZXJ5RWxlbWVudCB8fCBlbGVtZW50ICkgKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZWxlbWVudCA9IHF1ZXJ5RWxlbWVudDtcbiAgLy8gYWRkIGpRdWVyeVxuICBpZiAoIGpRdWVyeSApIHtcbiAgICB0aGlzLiRlbGVtZW50ID0galF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcbiAgfVxuXG4gIC8vIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKCB7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyApO1xuICB0aGlzLm9wdGlvbiggb3B0aW9ucyApO1xuXG4gIC8vIGFkZCBpZCBmb3IgT3V0bGF5ZXIuZ2V0RnJvbUVsZW1lbnRcbiAgdmFyIGlkID0gKytHVUlEO1xuICB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEID0gaWQ7IC8vIGV4cGFuZG9cbiAgaW5zdGFuY2VzWyBpZCBdID0gdGhpczsgLy8gYXNzb2NpYXRlIHZpYSBpZFxuXG4gIC8vIGtpY2sgaXQgb2ZmXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHZhciBpc0luaXRMYXlvdXQgPSB0aGlzLl9nZXRPcHRpb24oJ2luaXRMYXlvdXQnKTtcbiAgaWYgKCBpc0luaXRMYXlvdXQgKSB7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgfVxufVxuXG4vLyBzZXR0aW5ncyBhcmUgZm9yIGludGVybmFsIHVzZSBvbmx5XG5PdXRsYXllci5uYW1lc3BhY2UgPSAnb3V0bGF5ZXInO1xuT3V0bGF5ZXIuSXRlbSA9IEl0ZW07XG5cbi8vIGRlZmF1bHQgb3B0aW9uc1xuT3V0bGF5ZXIuZGVmYXVsdHMgPSB7XG4gIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfSxcbiAgaW5pdExheW91dDogdHJ1ZSxcbiAgb3JpZ2luTGVmdDogdHJ1ZSxcbiAgb3JpZ2luVG9wOiB0cnVlLFxuICByZXNpemU6IHRydWUsXG4gIHJlc2l6ZUNvbnRhaW5lcjogdHJ1ZSxcbiAgLy8gaXRlbSBvcHRpb25zXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogJzAuNHMnLFxuICBoaWRkZW5TdHlsZToge1xuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMC4wMDEpJ1xuICB9LFxuICB2aXNpYmxlU3R5bGU6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICB9XG59O1xuXG52YXIgcHJvdG8gPSBPdXRsYXllci5wcm90b3R5cGU7XG4vLyBpbmhlcml0IEV2RW1pdHRlclxudXRpbHMuZXh0ZW5kKCBwcm90bywgRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4vKipcbiAqIHNldCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5wcm90by5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcbiAgdXRpbHMuZXh0ZW5kKCB0aGlzLm9wdGlvbnMsIG9wdHMgKTtcbn07XG5cbi8qKlxuICogZ2V0IGJhY2t3YXJkcyBjb21wYXRpYmxlIG9wdGlvbiB2YWx1ZSwgY2hlY2sgb2xkIG5hbWVcbiAqL1xucHJvdG8uX2dldE9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb24gKSB7XG4gIHZhciBvbGRPcHRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLmNvbXBhdE9wdGlvbnNbIG9wdGlvbiBdO1xuICByZXR1cm4gb2xkT3B0aW9uICYmIHRoaXMub3B0aW9uc1sgb2xkT3B0aW9uIF0gIT09IHVuZGVmaW5lZCA/XG4gICAgdGhpcy5vcHRpb25zWyBvbGRPcHRpb24gXSA6IHRoaXMub3B0aW9uc1sgb3B0aW9uIF07XG59O1xuXG5PdXRsYXllci5jb21wYXRPcHRpb25zID0ge1xuICAvLyBjdXJyZW50TmFtZTogb2xkTmFtZVxuICBpbml0TGF5b3V0OiAnaXNJbml0TGF5b3V0JyxcbiAgaG9yaXpvbnRhbDogJ2lzSG9yaXpvbnRhbCcsXG4gIGxheW91dEluc3RhbnQ6ICdpc0xheW91dEluc3RhbnQnLFxuICBvcmlnaW5MZWZ0OiAnaXNPcmlnaW5MZWZ0JyxcbiAgb3JpZ2luVG9wOiAnaXNPcmlnaW5Ub3AnLFxuICByZXNpemU6ICdpc1Jlc2l6ZUJvdW5kJyxcbiAgcmVzaXplQ29udGFpbmVyOiAnaXNSZXNpemluZ0NvbnRhaW5lcidcbn07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZ2V0IGl0ZW1zIGZyb20gY2hpbGRyZW5cbiAgdGhpcy5yZWxvYWRJdGVtcygpO1xuICAvLyBlbGVtZW50cyB0aGF0IGFmZmVjdCBsYXlvdXQsIGJ1dCBhcmUgbm90IGxhaWQgb3V0XG4gIHRoaXMuc3RhbXBzID0gW107XG4gIHRoaXMuc3RhbXAoIHRoaXMub3B0aW9ucy5zdGFtcCApO1xuICAvLyBzZXQgY29udGFpbmVyIHN0eWxlXG4gIHV0aWxzLmV4dGVuZCggdGhpcy5lbGVtZW50LnN0eWxlLCB0aGlzLm9wdGlvbnMuY29udGFpbmVyU3R5bGUgKTtcblxuICAvLyBiaW5kIHJlc2l6ZSBtZXRob2RcbiAgdmFyIGNhbkJpbmRSZXNpemUgPSB0aGlzLl9nZXRPcHRpb24oJ3Jlc2l6ZScpO1xuICBpZiAoIGNhbkJpbmRSZXNpemUgKSB7XG4gICAgdGhpcy5iaW5kUmVzaXplKCk7XG4gIH1cbn07XG5cbi8vIGdvZXMgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWdhaW4gYW5kIGdldHMgYnJpY2tzIGluIHByb3BlciBvcmRlclxucHJvdG8ucmVsb2FkSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgLy8gY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gIHRoaXMuaXRlbXMgPSB0aGlzLl9pdGVtaXplKCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4gKTtcbn07XG5cblxuLyoqXG4gKiB0dXJuIGVsZW1lbnRzIGludG8gT3V0bGF5ZXIuSXRlbXMgdG8gYmUgdXNlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgSFRNTEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gY29sbGVjdGlvbiBvZiBuZXcgT3V0bGF5ZXIgSXRlbXNcbiAqL1xucHJvdG8uX2l0ZW1pemUgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cbiAgdmFyIGl0ZW1FbGVtcyA9IHRoaXMuX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMoIGVsZW1zICk7XG4gIHZhciBJdGVtID0gdGhpcy5jb25zdHJ1Y3Rvci5JdGVtO1xuXG4gIC8vIGNyZWF0ZSBuZXcgT3V0bGF5ZXIgSXRlbXMgZm9yIGNvbGxlY3Rpb25cbiAgdmFyIGl0ZW1zID0gW107XG4gIGZvciAoIHZhciBpPTA7IGkgPCBpdGVtRWxlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGVsZW0gPSBpdGVtRWxlbXNbaV07XG4gICAgdmFyIGl0ZW0gPSBuZXcgSXRlbSggZWxlbSwgdGhpcyApO1xuICAgIGl0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogZ2V0IGl0ZW0gZWxlbWVudHMgdG8gYmUgdXNlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgSFRNTEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gaXRlbSBlbGVtZW50c1xuICovXG5wcm90by5fZmlsdGVyRmluZEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgcmV0dXJuIHV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyggZWxlbXMsIHRoaXMub3B0aW9ucy5pdGVtU2VsZWN0b3IgKTtcbn07XG5cbi8qKlxuICogZ2V0dGVyIG1ldGhvZCBmb3IgZ2V0dGluZyBpdGVtIGVsZW1lbnRzXG4gKiBAcmV0dXJucyB7QXJyYXl9IGVsZW1zIC0gY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gKi9cbnByb3RvLmdldEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIHJldHVybiBpdGVtLmVsZW1lbnQ7XG4gIH0pO1xufTtcblxuLy8gLS0tLS0gaW5pdCAmIGxheW91dCAtLS0tLSAvL1xuXG4vKipcbiAqIGxheXMgb3V0IGFsbCBpdGVtc1xuICovXG5wcm90by5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzZXRMYXlvdXQoKTtcbiAgdGhpcy5fbWFuYWdlU3RhbXBzKCk7XG5cbiAgLy8gZG9uJ3QgYW5pbWF0ZSBmaXJzdCBsYXlvdXRcbiAgdmFyIGxheW91dEluc3RhbnQgPSB0aGlzLl9nZXRPcHRpb24oJ2xheW91dEluc3RhbnQnKTtcbiAgdmFyIGlzSW5zdGFudCA9IGxheW91dEluc3RhbnQgIT09IHVuZGVmaW5lZCA/XG4gICAgbGF5b3V0SW5zdGFudCA6ICF0aGlzLl9pc0xheW91dEluaXRlZDtcbiAgdGhpcy5sYXlvdXRJdGVtcyggdGhpcy5pdGVtcywgaXNJbnN0YW50ICk7XG5cbiAgLy8gZmxhZyBmb3IgaW5pdGFsaXplZFxuICB0aGlzLl9pc0xheW91dEluaXRlZCA9IHRydWU7XG59O1xuXG4vLyBfaW5pdCBpcyBhbGlhcyBmb3IgbGF5b3V0XG5wcm90by5faW5pdCA9IHByb3RvLmxheW91dDtcblxuLyoqXG4gKiBsb2dpYyBiZWZvcmUgYW55IG5ldyBsYXlvdXRcbiAqL1xucHJvdG8uX3Jlc2V0TGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2V0U2l6ZSgpO1xufTtcblxuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxuLyoqXG4gKiBnZXQgbWVhc3VyZW1lbnQgZnJvbSBvcHRpb24sIGZvciBjb2x1bW5XaWR0aCwgcm93SGVpZ2h0LCBndXR0ZXJcbiAqIGlmIG9wdGlvbiBpcyBTdHJpbmcgLT4gZ2V0IGVsZW1lbnQgZnJvbSBzZWxlY3RvciBzdHJpbmcsICYgZ2V0IHNpemUgb2YgZWxlbWVudFxuICogaWYgb3B0aW9uIGlzIEVsZW1lbnQgLT4gZ2V0IHNpemUgb2YgZWxlbWVudFxuICogZWxzZSB1c2Ugb3B0aW9uIGFzIGEgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lYXN1cmVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIHdpZHRoIG9yIGhlaWdodFxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX2dldE1lYXN1cmVtZW50ID0gZnVuY3Rpb24oIG1lYXN1cmVtZW50LCBzaXplICkge1xuICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zWyBtZWFzdXJlbWVudCBdO1xuICB2YXIgZWxlbTtcbiAgaWYgKCAhb3B0aW9uICkge1xuICAgIC8vIGRlZmF1bHQgdG8gMFxuICAgIHRoaXNbIG1lYXN1cmVtZW50IF0gPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBvcHRpb24gYXMgYW4gZWxlbWVudFxuICAgIGlmICggdHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyApIHtcbiAgICAgIGVsZW0gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvciggb3B0aW9uICk7XG4gICAgfSBlbHNlIGlmICggb3B0aW9uIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSB7XG4gICAgICBlbGVtID0gb3B0aW9uO1xuICAgIH1cbiAgICAvLyB1c2Ugc2l6ZSBvZiBlbGVtZW50LCBpZiBlbGVtZW50XG4gICAgdGhpc1sgbWVhc3VyZW1lbnQgXSA9IGVsZW0gPyBnZXRTaXplKCBlbGVtIClbIHNpemUgXSA6IG9wdGlvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBsYXlvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cbnByb3RvLmxheW91dEl0ZW1zID0gZnVuY3Rpb24oIGl0ZW1zLCBpc0luc3RhbnQgKSB7XG4gIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNGb3JMYXlvdXQoIGl0ZW1zICk7XG5cbiAgdGhpcy5fbGF5b3V0SXRlbXMoIGl0ZW1zLCBpc0luc3RhbnQgKTtcblxuICB0aGlzLl9wb3N0TGF5b3V0KCk7XG59O1xuXG4vKipcbiAqIGdldCB0aGUgaXRlbXMgdG8gYmUgbGFpZCBvdXRcbiAqIHlvdSBtYXkgd2FudCB0byBza2lwIG92ZXIgc29tZSBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXNcbiAqL1xucHJvdG8uX2dldEl0ZW1zRm9yTGF5b3V0ID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICByZXR1cm4gIWl0ZW0uaXNJZ25vcmVkO1xuICB9KTtcbn07XG5cbi8qKlxuICogbGF5b3V0IGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnRcbiAqL1xucHJvdG8uX2xheW91dEl0ZW1zID0gZnVuY3Rpb24oIGl0ZW1zLCBpc0luc3RhbnQgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdsYXlvdXQnLCBpdGVtcyApO1xuXG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgLy8gbm8gaXRlbXMsIGVtaXQgZXZlbnQgd2l0aCBlbXB0eSBhcnJheVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuXG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIC8vIGdldCB4L3kgb2JqZWN0IGZyb20gbWV0aG9kXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0SXRlbUxheW91dFBvc2l0aW9uKCBpdGVtICk7XG4gICAgLy8gZW5xdWV1ZVxuICAgIHBvc2l0aW9uLml0ZW0gPSBpdGVtO1xuICAgIHBvc2l0aW9uLmlzSW5zdGFudCA9IGlzSW5zdGFudCB8fCBpdGVtLmlzTGF5b3V0SW5zdGFudDtcbiAgICBxdWV1ZS5wdXNoKCBwb3NpdGlvbiApO1xuICB9LCB0aGlzICk7XG5cbiAgdGhpcy5fcHJvY2Vzc0xheW91dFF1ZXVlKCBxdWV1ZSApO1xufTtcblxuLyoqXG4gKiBnZXQgaXRlbSBsYXlvdXQgcG9zaXRpb25cbiAqIEBwYXJhbSB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICogQHJldHVybnMge09iamVjdH0geCBhbmQgeSBwb3NpdGlvblxuICovXG5wcm90by5fZ2V0SXRlbUxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oIC8qIGl0ZW0gKi8gKSB7XG4gIHJldHVybiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG59O1xuXG4vKipcbiAqIGl0ZXJhdGUgb3ZlciBhcnJheSBhbmQgcG9zaXRpb24gZWFjaCBpdGVtXG4gKiBSZWFzb24gYmVpbmcgLSBzZXBhcmF0aW5nIHRoaXMgbG9naWMgcHJldmVudHMgJ2xheW91dCBpbnZhbGlkYXRpb24nXG4gKiB0aHggQHBhdWxfaXJpc2hcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cbnByb3RvLl9wcm9jZXNzTGF5b3V0UXVldWUgPSBmdW5jdGlvbiggcXVldWUgKSB7XG4gIHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBxdWV1ZS5mb3JFYWNoKCBmdW5jdGlvbiggb2JqLCBpICkge1xuICAgIHRoaXMuX3Bvc2l0aW9uSXRlbSggb2JqLml0ZW0sIG9iai54LCBvYmoueSwgb2JqLmlzSW5zdGFudCwgaSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vLyBzZXQgc3RhZ2dlciBmcm9tIG9wdGlvbiBpbiBtaWxsaXNlY29uZHMgbnVtYmVyXG5wcm90by51cGRhdGVTdGFnZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFnZ2VyID0gdGhpcy5vcHRpb25zLnN0YWdnZXI7XG4gIGlmICggc3RhZ2dlciA9PT0gbnVsbCB8fCBzdGFnZ2VyID09PSB1bmRlZmluZWQgKSB7XG4gICAgdGhpcy5zdGFnZ2VyID0gMDtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zdGFnZ2VyID0gZ2V0TWlsbGlzZWNvbmRzKCBzdGFnZ2VyICk7XG4gIHJldHVybiB0aGlzLnN0YWdnZXI7XG59O1xuXG4vKipcbiAqIFNldHMgcG9zaXRpb24gb2YgaXRlbSBpbiBET01cbiAqIEBwYXJhbSB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICogQHBhcmFtIHtOdW1iZXJ9IHggLSBob3Jpem9udGFsIHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSAtIHZlcnRpY2FsIHBvc2l0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5zdGFudCAtIGRpc2FibGVzIHRyYW5zaXRpb25zXG4gKi9cbnByb3RvLl9wb3NpdGlvbkl0ZW0gPSBmdW5jdGlvbiggaXRlbSwgeCwgeSwgaXNJbnN0YW50LCBpICkge1xuICBpZiAoIGlzSW5zdGFudCApIHtcbiAgICAvLyBpZiBub3QgdHJhbnNpdGlvbiwganVzdCBzZXQgQ1NTXG4gICAgaXRlbS5nb1RvKCB4LCB5ICk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogdGhpcy5zdGFnZ2VyICk7XG4gICAgaXRlbS5tb3ZlVG8oIHgsIHkgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBbnkgbG9naWMgeW91IHdhbnQgdG8gZG8gYWZ0ZXIgZWFjaCBsYXlvdXQsXG4gKiBpLmUuIHNpemUgdGhlIGNvbnRhaW5lclxuICovXG5wcm90by5fcG9zdExheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc2l6ZUNvbnRhaW5lcigpO1xufTtcblxucHJvdG8ucmVzaXplQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1Jlc2l6aW5nQ29udGFpbmVyID0gdGhpcy5fZ2V0T3B0aW9uKCdyZXNpemVDb250YWluZXInKTtcbiAgaWYgKCAhaXNSZXNpemluZ0NvbnRhaW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNpemUgPSB0aGlzLl9nZXRDb250YWluZXJTaXplKCk7XG4gIGlmICggc2l6ZSApIHtcbiAgICB0aGlzLl9zZXRDb250YWluZXJNZWFzdXJlKCBzaXplLndpZHRoLCB0cnVlICk7XG4gICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS5oZWlnaHQsIGZhbHNlICk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB3aWR0aCBvciBoZWlnaHQgb2YgY29udGFpbmVyIGlmIHJldHVybmVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBzaXplXG4gKiAgIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogICBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKi9cbnByb3RvLl9nZXRDb250YWluZXJTaXplID0gbm9vcDtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbWVhc3VyZSAtIHNpemUgb2Ygd2lkdGggb3IgaGVpZ2h0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzV2lkdGhcbiAqL1xucHJvdG8uX3NldENvbnRhaW5lck1lYXN1cmUgPSBmdW5jdGlvbiggbWVhc3VyZSwgaXNXaWR0aCApIHtcbiAgaWYgKCBtZWFzdXJlID09PSB1bmRlZmluZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsZW1TaXplID0gdGhpcy5zaXplO1xuICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHdpZHRoIGlmIGJvcmRlciBib3hcbiAgaWYgKCBlbGVtU2l6ZS5pc0JvcmRlckJveCApIHtcbiAgICBtZWFzdXJlICs9IGlzV2lkdGggPyBlbGVtU2l6ZS5wYWRkaW5nTGVmdCArIGVsZW1TaXplLnBhZGRpbmdSaWdodCArXG4gICAgICBlbGVtU2l6ZS5ib3JkZXJMZWZ0V2lkdGggKyBlbGVtU2l6ZS5ib3JkZXJSaWdodFdpZHRoIDpcbiAgICAgIGVsZW1TaXplLnBhZGRpbmdCb3R0b20gKyBlbGVtU2l6ZS5wYWRkaW5nVG9wICtcbiAgICAgIGVsZW1TaXplLmJvcmRlclRvcFdpZHRoICsgZWxlbVNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG4gIH1cblxuICBtZWFzdXJlID0gTWF0aC5tYXgoIG1lYXN1cmUsIDAgKTtcbiAgdGhpcy5lbGVtZW50LnN0eWxlWyBpc1dpZHRoID8gJ3dpZHRoJyA6ICdoZWlnaHQnIF0gPSBtZWFzdXJlICsgJ3B4Jztcbn07XG5cbi8qKlxuICogZW1pdCBldmVudENvbXBsZXRlIG9uIGEgY29sbGVjdGlvbiBvZiBpdGVtcyBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbiAqL1xucHJvdG8uX2VtaXRDb21wbGV0ZU9uSXRlbXMgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBpdGVtcyApIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KCBldmVudE5hbWUgKyAnQ29tcGxldGUnLCBudWxsLCBbIGl0ZW1zIF0gKTtcbiAgfVxuXG4gIHZhciBjb3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgaWYgKCAhaXRlbXMgfHwgIWNvdW50ICkge1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZG9uZUNvdW50ID0gMDtcbiAgZnVuY3Rpb24gdGljaygpIHtcbiAgICBkb25lQ291bnQrKztcbiAgICBpZiAoIGRvbmVDb3VudCA9PSBjb3VudCApIHtcbiAgICAgIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBiaW5kIGNhbGxiYWNrXG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0ub25jZSggZXZlbnROYW1lLCB0aWNrICk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBlbWl0cyBldmVudHMgdmlhIEV2RW1pdHRlciBhbmQgalF1ZXJ5IGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZXh0cmEgYXJndW1lbnRzXG4gKi9cbnByb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIC8vIGFkZCBvcmlnaW5hbCBldmVudCB0byBhcmd1bWVudHNcbiAgdmFyIGVtaXRBcmdzID0gZXZlbnQgPyBbIGV2ZW50IF0uY29uY2F0KCBhcmdzICkgOiBhcmdzO1xuICB0aGlzLmVtaXRFdmVudCggdHlwZSwgZW1pdEFyZ3MgKTtcblxuICBpZiAoIGpRdWVyeSApIHtcbiAgICAvLyBzZXQgdGhpcy4kZWxlbWVudFxuICAgIHRoaXMuJGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50IHx8IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gICAgaWYgKCBldmVudCApIHtcbiAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgICAgIHZhciAkZXZlbnQgPSBqUXVlcnkuRXZlbnQoIGV2ZW50ICk7XG4gICAgICAkZXZlbnQudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHRyaWdnZXIgd2l0aCB0eXBlIGlmIG5vIGV2ZW50IGF2YWlsYWJsZVxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCB0eXBlLCBhcmdzICk7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpZ25vcmUgJiBzdGFtcHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuXG4vKipcbiAqIGtlZXAgaXRlbSBpbiBjb2xsZWN0aW9uLCBidXQgZG8gbm90IGxheSBpdCBvdXRcbiAqIGlnbm9yZWQgaXRlbXMgZG8gbm90IGdldCBza2lwcGVkIGluIGxheW91dFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKi9cbnByb3RvLmlnbm9yZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICBpZiAoIGl0ZW0gKSB7XG4gICAgaXRlbS5pc0lnbm9yZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIHJldHVybiBpdGVtIHRvIGxheW91dCBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqL1xucHJvdG8udW5pZ25vcmUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgaWYgKCBpdGVtICkge1xuICAgIGRlbGV0ZSBpdGVtLmlzSWdub3JlZDtcbiAgfVxufTtcblxuLyoqXG4gKiBhZGRzIGVsZW1lbnRzIHRvIHN0YW1wc1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIEVsZW1lbnQsIG9yIFN0cmluZ30gZWxlbXNcbiAqL1xucHJvdG8uc3RhbXAgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdGhpcy5fZmluZCggZWxlbXMgKTtcbiAgaWYgKCAhZWxlbXMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zdGFtcHMgPSB0aGlzLnN0YW1wcy5jb25jYXQoIGVsZW1zICk7XG4gIC8vIGlnbm9yZVxuICBlbGVtcy5mb3JFYWNoKCB0aGlzLmlnbm9yZSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiByZW1vdmVzIGVsZW1lbnRzIHRvIHN0YW1wc1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnVuc3RhbXAgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdGhpcy5fZmluZCggZWxlbXMgKTtcbiAgaWYgKCAhZWxlbXMgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAvLyBmaWx0ZXIgb3V0IHJlbW92ZWQgc3RhbXAgZWxlbWVudHNcbiAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLnN0YW1wcywgZWxlbSApO1xuICAgIHRoaXMudW5pZ25vcmUoIGVsZW0gKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiBmaW5kcyBjaGlsZCBlbGVtZW50c1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIEVsZW1lbnQsIG9yIFN0cmluZ30gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gZWxlbXNcbiAqL1xucHJvdG8uX2ZpbmQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGlmICggIWVsZW1zICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBpZiBzdHJpbmcsIHVzZSBhcmd1bWVudCBhcyBzZWxlY3RvciBzdHJpbmdcbiAgaWYgKCB0eXBlb2YgZWxlbXMgPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggZWxlbXMgKTtcbiAgfVxuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgcmV0dXJuIGVsZW1zO1xufTtcblxucHJvdG8uX21hbmFnZVN0YW1wcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLnN0YW1wcyB8fCAhdGhpcy5zdGFtcHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2dldEJvdW5kaW5nUmVjdCgpO1xuXG4gIHRoaXMuc3RhbXBzLmZvckVhY2goIHRoaXMuX21hbmFnZVN0YW1wLCB0aGlzICk7XG59O1xuXG4vLyB1cGRhdGUgYm91bmRpbmdMZWZ0IC8gVG9wXG5wcm90by5fZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGdldCBib3VuZGluZyByZWN0IGZvciBjb250YWluZXIgZWxlbWVudFxuICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgdGhpcy5fYm91bmRpbmdSZWN0ID0ge1xuICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0ICsgc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUuYm9yZGVyTGVmdFdpZHRoLFxuICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCArIHNpemUucGFkZGluZ1RvcCArIHNpemUuYm9yZGVyVG9wV2lkdGgsXG4gICAgcmlnaHQ6IGJvdW5kaW5nUmVjdC5yaWdodCAtICggc2l6ZS5wYWRkaW5nUmlnaHQgKyBzaXplLmJvcmRlclJpZ2h0V2lkdGggKSxcbiAgICBib3R0b206IGJvdW5kaW5nUmVjdC5ib3R0b20gLSAoIHNpemUucGFkZGluZ0JvdHRvbSArIHNpemUuYm9yZGVyQm90dG9tV2lkdGggKVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHN0YW1wXG4qKi9cbnByb3RvLl9tYW5hZ2VTdGFtcCA9IG5vb3A7XG5cbi8qKlxuICogZ2V0IHgveSBwb3NpdGlvbiBvZiBlbGVtZW50IHJlbGF0aXZlIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9mZnNldCAtIGhhcyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAqL1xucHJvdG8uX2dldEVsZW1lbnRPZmZzZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB0aGlzUmVjdCA9IHRoaXMuX2JvdW5kaW5nUmVjdDtcbiAgdmFyIHNpemUgPSBnZXRTaXplKCBlbGVtICk7XG4gIHZhciBvZmZzZXQgPSB7XG4gICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgLSB0aGlzUmVjdC5sZWZ0IC0gc2l6ZS5tYXJnaW5MZWZ0LFxuICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCAtIHRoaXNSZWN0LnRvcCAtIHNpemUubWFyZ2luVG9wLFxuICAgIHJpZ2h0OiB0aGlzUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5yaWdodCAtIHNpemUubWFyZ2luUmlnaHQsXG4gICAgYm90dG9tOiB0aGlzUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QuYm90dG9tIC0gc2l6ZS5tYXJnaW5Cb3R0b21cbiAgfTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHJlc2l6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBlbmFibGUgZXZlbnQgaGFuZGxlcnMgZm9yIGxpc3RlbmVyc1xuLy8gaS5lLiByZXNpemUgLT4gb25yZXNpemVcbnByb3RvLmhhbmRsZUV2ZW50ID0gdXRpbHMuaGFuZGxlRXZlbnQ7XG5cbi8qKlxuICogQmluZCBsYXlvdXQgdG8gd2luZG93IHJlc2l6aW5nXG4gKi9cbnByb3RvLmJpbmRSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuaXNSZXNpemVCb3VuZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIFVuYmluZCBsYXlvdXQgdG8gd2luZG93IHJlc2l6aW5nXG4gKi9cbnByb3RvLnVuYmluZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMgKTtcbiAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gZmFsc2U7XG59O1xuXG5wcm90by5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc2l6ZSgpO1xufTtcblxudXRpbHMuZGVib3VuY2VNZXRob2QoIE91dGxheWVyLCAnb25yZXNpemUnLCAxMDAgKTtcblxucHJvdG8ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvbid0IHRyaWdnZXIgaWYgc2l6ZSBkaWQgbm90IGNoYW5nZVxuICAvLyBvciBpZiByZXNpemUgd2FzIHVuYm91bmQuIFNlZSAjOVxuICBpZiAoICF0aGlzLmlzUmVzaXplQm91bmQgfHwgIXRoaXMubmVlZHNSZXNpemVMYXlvdXQoKSApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmxheW91dCgpO1xufTtcblxuLyoqXG4gKiBjaGVjayBpZiBsYXlvdXQgaXMgbmVlZGVkIHBvc3QgbGF5b3V0XG4gKiBAcmV0dXJucyBCb29sZWFuXG4gKi9cbnByb3RvLm5lZWRzUmVzaXplTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG4gIC8vIGNoZWNrIHRoYXQgdGhpcy5zaXplIGFuZCBzaXplIGFyZSB0aGVyZVxuICAvLyBJRTggdHJpZ2dlcnMgcmVzaXplIG9uIGJvZHkgc2l6ZSBjaGFuZ2UsIHNvIHRoZXkgbWlnaHQgbm90IGJlXG4gIHZhciBoYXNTaXplcyA9IHRoaXMuc2l6ZSAmJiBzaXplO1xuICByZXR1cm4gaGFzU2l6ZXMgJiYgc2l6ZS5pbm5lcldpZHRoICE9PSB0aGlzLnNpemUuaW5uZXJXaWR0aDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBhZGQgaXRlbXMgdG8gT3V0bGF5ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuKiovXG5wcm90by5hZGRJdGVtcyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgLy8gYWRkIGl0ZW1zIHRvIGNvbGxlY3Rpb25cbiAgaWYgKCBpdGVtcy5sZW5ndGggKSB7XG4gICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuY29uY2F0KCBpdGVtcyApO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogTGF5b3V0IG5ld2x5LWFwcGVuZGVkIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8uYXBwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuYWRkSXRlbXMoIGVsZW1zICk7XG4gIGlmICggIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbGF5b3V0IGFuZCByZXZlYWwganVzdCB0aGUgbmV3IGl0ZW1zXG4gIHRoaXMubGF5b3V0SXRlbXMoIGl0ZW1zLCB0cnVlICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgcHJlcGVuZGVkIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnByZXBlbmRlZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgaWYgKCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgaXRlbXMgdG8gYmVnaW5uaW5nIG9mIGNvbGxlY3Rpb25cbiAgdmFyIHByZXZpb3VzSXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDApO1xuICB0aGlzLml0ZW1zID0gaXRlbXMuY29uY2F0KCBwcmV2aW91c0l0ZW1zICk7XG4gIC8vIHN0YXJ0IG5ldyBsYXlvdXRcbiAgdGhpcy5fcmVzZXRMYXlvdXQoKTtcbiAgdGhpcy5fbWFuYWdlU3RhbXBzKCk7XG4gIC8vIGxheW91dCBuZXcgc3R1ZmYgd2l0aG91dCB0cmFuc2l0aW9uXG4gIHRoaXMubGF5b3V0SXRlbXMoIGl0ZW1zLCB0cnVlICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xuICAvLyBsYXlvdXQgcHJldmlvdXMgaXRlbXNcbiAgdGhpcy5sYXlvdXRJdGVtcyggcHJldmlvdXNJdGVtcyApO1xufTtcblxuLyoqXG4gKiByZXZlYWwgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5IG9mIE91dGxheWVyLkl0ZW1zfSBpdGVtc1xuICovXG5wcm90by5yZXZlYWwgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdyZXZlYWwnLCBpdGVtcyApO1xuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhZ2dlciA9IHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiBzdGFnZ2VyICk7XG4gICAgaXRlbS5yZXZlYWwoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGhpZGUgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5IG9mIE91dGxheWVyLkl0ZW1zfSBpdGVtc1xuICovXG5wcm90by5oaWRlID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAnaGlkZScsIGl0ZW1zICk7XG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdGFnZ2VyID0gdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHN0YWdnZXIgKTtcbiAgICBpdGVtLmhpZGUoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIHJldmVhbCBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSwge0VsZW1lbnR9LCB7Tm9kZUxpc3R9IGl0ZW1zXG4gKi9cbnByb3RvLnJldmVhbEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIGhpZGUgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0sIHtFbGVtZW50fSwge05vZGVMaXN0fSBpdGVtc1xuICovXG5wcm90by5oaWRlSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICB0aGlzLmhpZGUoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIGdldCBPdXRsYXllci5JdGVtLCBnaXZlbiBhbiBFbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICovXG5wcm90by5nZXRJdGVtID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGxvb3AgdGhyb3VnaCBpdGVtcyB0byBnZXQgdGhlIG9uZSB0aGF0IG1hdGNoZXNcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuICAgIGlmICggaXRlbS5lbGVtZW50ID09IGVsZW0gKSB7XG4gICAgICAvLyByZXR1cm4gaXRlbVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdldCBjb2xsZWN0aW9uIG9mIE91dGxheWVyLkl0ZW1zLCBnaXZlbiBFbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICovXG5wcm90by5nZXRJdGVtcyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICAgIGlmICggaXRlbSApIHtcbiAgICAgIGl0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgICB9XG4gIH0sIHRoaXMgKTtcblxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIHJlbW92ZSBlbGVtZW50KHMpIGZyb20gaW5zdGFuY2UgYW5kIERPTVxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciByZW1vdmVJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG5cbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ3JlbW92ZScsIHJlbW92ZUl0ZW1zICk7XG5cbiAgLy8gYmFpbCBpZiBubyBpdGVtcyB0byByZW1vdmVcbiAgaWYgKCAhcmVtb3ZlSXRlbXMgfHwgIXJlbW92ZUl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZW1vdmVJdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLnJlbW92ZSgpO1xuICAgIC8vIHJlbW92ZSBpdGVtIGZyb20gY29sbGVjdGlvblxuICAgIHV0aWxzLnJlbW92ZUZyb20oIHRoaXMuaXRlbXMsIGl0ZW0gKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLy8gLS0tLS0gZGVzdHJveSAtLS0tLSAvL1xuXG4vLyByZW1vdmUgYW5kIGRpc2FibGUgT3V0bGF5ZXIgaW5zdGFuY2VcbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2xlYW4gdXAgZHluYW1pYyBzdHlsZXNcbiAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgc3R5bGUucG9zaXRpb24gPSAnJztcbiAgc3R5bGUud2lkdGggPSAnJztcbiAgLy8gZGVzdHJveSBpdGVtc1xuICB0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0uZGVzdHJveSgpO1xuICB9KTtcblxuICB0aGlzLnVuYmluZFJlc2l6ZSgpO1xuXG4gIHZhciBpZCA9IHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQ7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbIGlkIF07IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gaW5zdGFuY2UgYnkgaWRcbiAgZGVsZXRlIHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQ7XG4gIC8vIHJlbW92ZSBkYXRhIGZvciBqUXVlcnlcbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgalF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lc3BhY2UgKTtcbiAgfVxuXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkYXRhIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogZ2V0IE91dGxheWVyIGluc3RhbmNlIGZyb20gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7T3V0bGF5ZXJ9XG4gKi9cbk91dGxheWVyLmRhdGEgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgZWxlbSA9IHV0aWxzLmdldFF1ZXJ5RWxlbWVudCggZWxlbSApO1xuICB2YXIgaWQgPSBlbGVtICYmIGVsZW0ub3V0bGF5ZXJHVUlEO1xuICByZXR1cm4gaWQgJiYgaW5zdGFuY2VzWyBpZCBdO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBjcmVhdGUgT3V0bGF5ZXIgY2xhc3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBjcmVhdGUgYSBsYXlvdXQgY2xhc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqL1xuT3V0bGF5ZXIuY3JlYXRlID0gZnVuY3Rpb24oIG5hbWVzcGFjZSwgb3B0aW9ucyApIHtcbiAgLy8gc3ViLWNsYXNzIE91dGxheWVyXG4gIHZhciBMYXlvdXQgPSBzdWJjbGFzcyggT3V0bGF5ZXIgKTtcbiAgLy8gYXBwbHkgbmV3IG9wdGlvbnMgYW5kIGNvbXBhdE9wdGlvbnNcbiAgTGF5b3V0LmRlZmF1bHRzID0gdXRpbHMuZXh0ZW5kKCB7fSwgT3V0bGF5ZXIuZGVmYXVsdHMgKTtcbiAgdXRpbHMuZXh0ZW5kKCBMYXlvdXQuZGVmYXVsdHMsIG9wdGlvbnMgKTtcbiAgTGF5b3V0LmNvbXBhdE9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCBPdXRsYXllci5jb21wYXRPcHRpb25zICApO1xuXG4gIExheW91dC5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgTGF5b3V0LmRhdGEgPSBPdXRsYXllci5kYXRhO1xuXG4gIC8vIHN1Yi1jbGFzcyBJdGVtXG4gIExheW91dC5JdGVtID0gc3ViY2xhc3MoIEl0ZW0gKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkZWNsYXJhdGl2ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIHV0aWxzLmh0bWxJbml0KCBMYXlvdXQsIG5hbWVzcGFjZSApO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGpRdWVyeSBicmlkZ2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvLyBtYWtlIGludG8galF1ZXJ5IHBsdWdpblxuICBpZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcbiAgICBqUXVlcnkuYnJpZGdldCggbmFtZXNwYWNlLCBMYXlvdXQgKTtcbiAgfVxuXG4gIHJldHVybiBMYXlvdXQ7XG59O1xuXG5mdW5jdGlvbiBzdWJjbGFzcyggUGFyZW50ICkge1xuICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcbiAgICBQYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB9XG5cbiAgU3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuICBTdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJDbGFzcztcblxuICByZXR1cm4gU3ViQ2xhc3M7XG59XG5cbi8vIC0tLS0tIGhlbHBlcnMgLS0tLS0gLy9cblxuLy8gaG93IG1hbnkgbWlsbGlzZWNvbmRzIGFyZSBpbiBlYWNoIHVuaXRcbnZhciBtc1VuaXRzID0ge1xuICBtczogMSxcbiAgczogMTAwMFxufTtcblxuLy8gbXVuZ2UgdGltZS1saWtlIHBhcmFtZXRlciBpbnRvIG1pbGxpc2Vjb25kIG51bWJlclxuLy8gJzAuNHMnIC0+IDQwXG5mdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoIHRpbWUgKSB7XG4gIGlmICggdHlwZW9mIHRpbWUgPT0gJ251bWJlcicgKSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgdmFyIG1hdGNoZXMgPSB0aW1lLm1hdGNoKCAvKF5cXGQqXFwuP1xcZCopKFxcdyopLyApO1xuICB2YXIgbnVtID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuICB2YXIgdW5pdCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1syXTtcbiAgaWYgKCAhbnVtLmxlbmd0aCApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBudW0gPSBwYXJzZUZsb2F0KCBudW0gKTtcbiAgdmFyIG11bHQgPSBtc1VuaXRzWyB1bml0IF0gfHwgMTtcbiAgcmV0dXJuIG51bSAqIG11bHQ7XG59XG5cbi8vIC0tLS0tIGZpbiAtLS0tLSAvL1xuXG4vLyBiYWNrIGluIGdsb2JhbFxuT3V0bGF5ZXIuSXRlbSA9IEl0ZW07XG5cbnJldHVybiBPdXRsYXllcjtcblxufSkpO1xuIl0sIm5hbWVzIjpbIndpbmRvdyIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJFdkVtaXR0ZXIiLCJnZXRTaXplIiwidXRpbHMiLCJJdGVtIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJPdXRsYXllciIsImZpenp5VUlVdGlscyIsImNvbnNvbGUiLCJqUXVlcnkiLCJub29wIiwiR1VJRCIsImluc3RhbmNlcyIsImVsZW1lbnQiLCJvcHRpb25zIiwicXVlcnlFbGVtZW50IiwiZ2V0UXVlcnlFbGVtZW50IiwiZXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWVzcGFjZSIsIiRlbGVtZW50IiwiZXh0ZW5kIiwiZGVmYXVsdHMiLCJvcHRpb24iLCJpZCIsIm91dGxheWVyR1VJRCIsIl9jcmVhdGUiLCJpc0luaXRMYXlvdXQiLCJfZ2V0T3B0aW9uIiwibGF5b3V0IiwiY29udGFpbmVyU3R5bGUiLCJwb3NpdGlvbiIsImluaXRMYXlvdXQiLCJvcmlnaW5MZWZ0Iiwib3JpZ2luVG9wIiwicmVzaXplIiwicmVzaXplQ29udGFpbmVyIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiaGlkZGVuU3R5bGUiLCJvcGFjaXR5IiwidHJhbnNmb3JtIiwidmlzaWJsZVN0eWxlIiwicHJvdG8iLCJwcm90b3R5cGUiLCJvcHRzIiwib2xkT3B0aW9uIiwiY29tcGF0T3B0aW9ucyIsInVuZGVmaW5lZCIsImhvcml6b250YWwiLCJsYXlvdXRJbnN0YW50IiwicmVsb2FkSXRlbXMiLCJzdGFtcHMiLCJzdGFtcCIsInN0eWxlIiwiY2FuQmluZFJlc2l6ZSIsImJpbmRSZXNpemUiLCJpdGVtcyIsIl9pdGVtaXplIiwiY2hpbGRyZW4iLCJlbGVtcyIsIml0ZW1FbGVtcyIsIl9maWx0ZXJGaW5kSXRlbUVsZW1lbnRzIiwiaSIsImxlbmd0aCIsImVsZW0iLCJpdGVtIiwicHVzaCIsImZpbHRlckZpbmRFbGVtZW50cyIsIml0ZW1TZWxlY3RvciIsImdldEl0ZW1FbGVtZW50cyIsIm1hcCIsIl9yZXNldExheW91dCIsIl9tYW5hZ2VTdGFtcHMiLCJpc0luc3RhbnQiLCJfaXNMYXlvdXRJbml0ZWQiLCJsYXlvdXRJdGVtcyIsIl9pbml0Iiwic2l6ZSIsIl9nZXRNZWFzdXJlbWVudCIsIm1lYXN1cmVtZW50IiwicXVlcnlTZWxlY3RvciIsIkhUTUxFbGVtZW50IiwiX2dldEl0ZW1zRm9yTGF5b3V0IiwiX2xheW91dEl0ZW1zIiwiX3Bvc3RMYXlvdXQiLCJmaWx0ZXIiLCJpc0lnbm9yZWQiLCJfZW1pdENvbXBsZXRlT25JdGVtcyIsInF1ZXVlIiwiZm9yRWFjaCIsIl9nZXRJdGVtTGF5b3V0UG9zaXRpb24iLCJpc0xheW91dEluc3RhbnQiLCJfcHJvY2Vzc0xheW91dFF1ZXVlIiwieCIsInkiLCJ1cGRhdGVTdGFnZ2VyIiwib2JqIiwiX3Bvc2l0aW9uSXRlbSIsInN0YWdnZXIiLCJnZXRNaWxsaXNlY29uZHMiLCJnb1RvIiwibW92ZVRvIiwiaXNSZXNpemluZ0NvbnRhaW5lciIsIl9nZXRDb250YWluZXJTaXplIiwiX3NldENvbnRhaW5lck1lYXN1cmUiLCJ3aWR0aCIsImhlaWdodCIsIm1lYXN1cmUiLCJpc1dpZHRoIiwiZWxlbVNpemUiLCJpc0JvcmRlckJveCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIk1hdGgiLCJtYXgiLCJldmVudE5hbWUiLCJfdGhpcyIsIm9uQ29tcGxldGUiLCJkaXNwYXRjaEV2ZW50IiwiY291bnQiLCJkb25lQ291bnQiLCJ0aWNrIiwib25jZSIsInR5cGUiLCJldmVudCIsImFyZ3MiLCJlbWl0QXJncyIsImNvbmNhdCIsImVtaXRFdmVudCIsIiRldmVudCIsIkV2ZW50IiwidHJpZ2dlciIsImlnbm9yZSIsImdldEl0ZW0iLCJ1bmlnbm9yZSIsIl9maW5kIiwidW5zdGFtcCIsInJlbW92ZUZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFrZUFycmF5IiwiX2dldEJvdW5kaW5nUmVjdCIsIl9tYW5hZ2VTdGFtcCIsImJvdW5kaW5nUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9ib3VuZGluZ1JlY3QiLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJfZ2V0RWxlbWVudE9mZnNldCIsInRoaXNSZWN0Iiwib2Zmc2V0IiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwiaGFuZGxlRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaXNSZXNpemVCb3VuZCIsInVuYmluZFJlc2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbnJlc2l6ZSIsImRlYm91bmNlTWV0aG9kIiwibmVlZHNSZXNpemVMYXlvdXQiLCJoYXNTaXplcyIsImlubmVyV2lkdGgiLCJhZGRJdGVtcyIsImFwcGVuZGVkIiwicmV2ZWFsIiwicHJlcGVuZGVkIiwicHJldmlvdXNJdGVtcyIsInNsaWNlIiwiaGlkZSIsInJldmVhbEl0ZW1FbGVtZW50cyIsImdldEl0ZW1zIiwiaGlkZUl0ZW1FbGVtZW50cyIsInJlbW92ZSIsInJlbW92ZUl0ZW1zIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJkYXRhIiwiY3JlYXRlIiwiTGF5b3V0Iiwic3ViY2xhc3MiLCJodG1sSW5pdCIsImJyaWRnZXQiLCJQYXJlbnQiLCJTdWJDbGFzcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiT2JqZWN0IiwibXNVbml0cyIsIm1zIiwicyIsInRpbWUiLCJtYXRjaGVzIiwibWF0Y2giLCJudW0iLCJ1bml0IiwicGFyc2VGbG9hdCIsIm11bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/outlayer.js\n");

/***/ })

};
;